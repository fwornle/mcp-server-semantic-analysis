"""
Documentation Agent
Handles automated documentation generation and template management
"""

import asyncio
import json
import os
import subprocess
import sys
from pathlib import Path
from typing import Dict, Any, List, Optional
import time
from string import Template
import uuid
import re

from .base import BaseAgent


class DocumentationAgent(BaseAgent):
    """Agent for generating documentation from analysis results."""
    
    def __init__(self, name: str, config: Dict[str, Any], system: Any):
        super().__init__(name, config, system)
        
        self.generation_config = config.get("generation", {})
        self.auto_generation_config = config.get("auto_generation", {})
        self.template_dir = Path(self.generation_config.get("template_dir", "templates"))
        self.output_format = self.generation_config.get("output_format", "markdown")
        
        # PlantUML and diagram configuration
        self.plantuml_config = config.get("plantuml", {})
        self.insights_dir = Path(self.plantuml_config.get("insights_dir", "../../../knowledge-management/insights"))
        self.puml_dir = self.insights_dir / "puml"
        self.images_dir = self.insights_dir / "images"
        self.standard_style_path = Path(self.plantuml_config.get("standard_style", "../../../docs/puml/_standard-style.puml"))
        
        # UKB integration configuration  
        self.ukb_config = config.get("ukb_integration", {})
        self.ukb_command = self.ukb_config.get("ukb_command", "ukb")
        
        self.register_capability("document_generation")
        self.register_capability("template_management")
        self.register_capability("auto_documentation")
        self.register_capability("plantuml_generation")
        self.register_capability("ukb_integration")
        self.register_capability("insight_generation")
    
    async def on_initialize(self):
        """Initialize documentation agent."""
        self.logger.info("CRITICAL DEBUG: DocumentationAgent.on_initialize() called")
        
        # Create template directory if it doesn't exist
        self.template_dir.mkdir(parents=True, exist_ok=True)
        
        # Create PlantUML and insight directories
        self.puml_dir.mkdir(parents=True, exist_ok=True)
        self.images_dir.mkdir(parents=True, exist_ok=True)
        
        # Create default templates
        await self._create_default_templates()
        
        # Check PlantUML availability
        await self._check_plantuml_availability()
        
        self.logger.info("CRITICAL DEBUG: About to register event handlers...")
        self._register_event_handlers()
        self.logger.info(f"CRITICAL DEBUG: Event handlers registered: {list(self._event_handlers.keys())}")
        self.logger.info(f"CRITICAL DEBUG: Total handlers count: {len(self._event_handlers)}")
    
    def _register_event_handlers(self):
        """Register event handlers."""
        self.logger.info(f"DEBUG: DocumentationAgent._register_event_handlers called")
        self.register_event_handler("generate_report", self._handle_generate_report)
        self.register_event_handler("generate_analysis_doc", self._handle_generate_analysis_doc)
        self.register_event_handler("generate_workflow_doc", self._handle_generate_workflow_doc)
        self.register_event_handler("create_template", self._handle_create_template)
        self.register_event_handler("list_templates", self._handle_list_templates)
        
        # PlantUML and insight generation handlers
        self.register_event_handler("generate_plantuml_diagram", self._handle_generate_plantuml_diagram)
        self.register_event_handler("convert_puml_to_png", self._handle_convert_puml_to_png)
        self.register_event_handler("create_insight_document", self._handle_create_insight_document)
        self.register_event_handler("create_ukb_entity_with_insight", self._handle_create_ukb_entity_with_insight)
        self.register_event_handler("generate_lessons_learned", self._handle_generate_lessons_learned)
        self.logger.info(f"DEBUG: DocumentationAgent registered {len(self._event_handlers)} event handlers")
    
    async def _create_default_templates(self):
        """Create default documentation templates."""
        templates = {
            "analysis_report.md": """# Semantic Analysis Report

**Generated**: ${timestamp}
**Repository**: ${repository}
**Analysis Type**: ${analysis_type}

## Summary

${summary}

## Key Findings

${findings}

## Entities Created

${entities_summary}

## Recommendations

${recommendations}

## Technical Details

- **Duration**: ${duration}
- **Entities Processed**: ${entity_count}
- **Significance Threshold**: ${significance_threshold}
- **Agent**: ${agent_name}

---
*Generated by Semantic Analysis System*
""",
            
            "workflow_report.md": """# Workflow Execution Report

**Workflow**: ${workflow_name}
**Status**: ${status}
**Duration**: ${duration}
**Completed**: ${timestamp}

## Workflow Steps

${steps_summary}

## Results Summary

${results_summary}

## Quality Assurance

${qa_summary}

## Errors and Warnings

${errors_warnings}

---
*Generated automatically by Coordinator Agent*
""",
            
            "entity_summary.md": """# Entity Summary Report

**Generated**: ${timestamp}
**Total Entities**: ${total_entities}

## Entities by Type

${entities_by_type}

## High Significance Entities

${high_significance_entities}

## Recent Entities

${recent_entities}

---
*Generated by Knowledge Graph Agent*
"""
        }
        
        for template_name, content in templates.items():
            template_path = self.template_dir / template_name
            if not template_path.exists():
                with open(template_path, 'w') as f:
                    f.write(content)
                self.logger.debug(f"Created default template: {template_name}")
    
    async def generate_analysis_report(self, analysis_results: Dict[str, Any], metadata: Dict[str, Any] = None) -> Dict[str, Any]:
        """Generate a comprehensive analysis report."""
        metadata = metadata or {}
        
        try:
            # Prepare template variables
            template_vars = {
                "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
                "repository": metadata.get("repository", "Unknown"),
                "analysis_type": metadata.get("analysis_type", "General"),
                "summary": self._generate_summary(analysis_results),
                "findings": self._format_findings(analysis_results),
                "entities_summary": self._format_entities_summary(analysis_results),
                "recommendations": self._generate_recommendations(analysis_results),
                "duration": metadata.get("duration", "Unknown"),
                "entity_count": metadata.get("entity_count", 0),
                "significance_threshold": metadata.get("significance_threshold", 5),
                "agent_name": "Semantic Analysis Agent"
            }
            
            # Generate document using template
            document = await self._apply_template("analysis_report.md", template_vars)
            
            # Save document if requested
            output_path = None
            if metadata.get("save_to_file"):
                output_path = await self._save_document(document, f"analysis_report_{int(time.time())}.md")
            
            return {
                "success": True,
                "document": document,
                "output_path": output_path,
                "template_used": "analysis_report.md"
            }
            
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    async def generate_workflow_report(self, workflow_execution: Any) -> Dict[str, Any]:
        """Generate a workflow execution report."""
        try:
            # Extract workflow information
            steps_summary = self._format_workflow_steps(workflow_execution.steps)
            results_summary = self._format_workflow_results(workflow_execution.results)
            qa_summary = self._format_qa_reports(workflow_execution.qa_reports)
            errors_warnings = self._format_errors_warnings(workflow_execution)
            
            template_vars = {
                "workflow_name": workflow_execution.name,
                "status": workflow_execution.status.value,
                "duration": f"{workflow_execution.end_time - workflow_execution.start_time:.1f}s" if workflow_execution.end_time else "Running",
                "timestamp": time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(workflow_execution.end_time)) if workflow_execution.end_time else "In Progress",
                "steps_summary": steps_summary,
                "results_summary": results_summary,
                "qa_summary": qa_summary,
                "errors_warnings": errors_warnings
            }
            
            document = await self._apply_template("workflow_report.md", template_vars)
            
            return {
                "success": True,
                "document": document,
                "workflow_id": workflow_execution.id,
                "template_used": "workflow_report.md"
            }
            
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    async def generate_entity_summary(self) -> Dict[str, Any]:
        """Generate a summary of all entities in the knowledge graph."""
        try:
            kg_agent = self.system.agents.get("knowledge_graph")
            if not kg_agent:
                return {"success": False, "error": "Knowledge graph agent not available"}
            
            entities = kg_agent.entities
            
            # Analyze entities
            entities_by_type = {}
            high_significance = []
            recent_entities = []
            
            current_time = time.time()
            
            for entity in entities.values():
                # Group by type
                entity_type = entity.entity_type
                if entity_type not in entities_by_type:
                    entities_by_type[entity_type] = 0
                entities_by_type[entity_type] += 1
                
                # High significance entities
                if entity.significance >= 8:
                    high_significance.append({
                        "name": entity.name,
                        "type": entity.entity_type,
                        "significance": entity.significance
                    })
                
                # Recent entities (last 24 hours)
                if current_time - entity.created_at < 86400:
                    recent_entities.append({
                        "name": entity.name,
                        "type": entity.entity_type,
                        "created_at": time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(entity.created_at))
                    })
            
            template_vars = {
                "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
                "total_entities": len(entities),
                "entities_by_type": self._format_entities_by_type(entities_by_type),
                "high_significance_entities": self._format_high_significance_entities(high_significance),
                "recent_entities": self._format_recent_entities(recent_entities)
            }
            
            document = await self._apply_template("entity_summary.md", template_vars)
            
            return {
                "success": True,
                "document": document,
                "statistics": {
                    "total_entities": len(entities),
                    "entity_types": len(entities_by_type),
                    "high_significance_count": len(high_significance),
                    "recent_count": len(recent_entities)
                }
            }
            
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    async def _apply_template(self, template_name: str, variables: Dict[str, Any]) -> str:
        """Apply template with variables."""
        template_path = self.template_dir / template_name
        
        if not template_path.exists():
            raise ValueError(f"Template not found: {template_name}")
        
        with open(template_path, 'r') as f:
            template_content = f.read()
        
        template = Template(template_content)
        return template.safe_substitute(variables)
    
    async def _save_document(self, document: str, filename: str) -> str:
        """Save document to file."""
        output_dir = Path(__file__).parent.parent / "reports"
        output_dir.mkdir(exist_ok=True)
        
        output_path = output_dir / filename
        with open(output_path, 'w') as f:
            f.write(document)
        
        return str(output_path)
    
    def _generate_summary(self, analysis_results: Dict[str, Any]) -> str:
        """Generate a summary from analysis results."""
        if "result" in analysis_results:
            result = analysis_results["result"]
            if isinstance(result, dict) and "analysis" in result:
                analysis_text = result["analysis"]
                # Extract first paragraph or first 200 characters
                lines = analysis_text.split('\n')
                first_paragraph = lines[0] if lines else analysis_text
                return first_paragraph[:200] + "..." if len(first_paragraph) > 200 else first_paragraph
        
        return "Analysis completed successfully with semantic insights extracted."
    
    def _format_findings(self, analysis_results: Dict[str, Any]) -> str:
        """Format key findings from analysis results."""
        findings = []
        
        if "result" in analysis_results:
            result = analysis_results["result"]
            if isinstance(result, dict):
                if "structured" in result and result["structured"]:
                    for key, value in result["structured"].items():
                        findings.append(f"- **{key.replace('_', ' ').title()}**: {value}")
                
                if "patterns" in result:
                    findings.append("- **Patterns Detected**: " + ", ".join(p.get("type", "Unknown") for p in result["patterns"]))
        
        return "\n".join(findings) if findings else "No specific findings available."
    
    def _format_entities_summary(self, analysis_results: Dict[str, Any]) -> str:
        """Format entities summary."""
        return f"Entities created during this analysis session. See Knowledge Graph for details."
    
    def _generate_recommendations(self, analysis_results: Dict[str, Any]) -> str:
        """Generate recommendations based on analysis results."""
        recommendations = [
            "Review high-significance patterns for potential architecture improvements",
            "Consider implementing identified best practices across the codebase",
            "Monitor entities with low significance scores for potential consolidation"
        ]
        
        return "\n".join(f"- {rec}" for rec in recommendations)
    
    def _format_workflow_steps(self, steps: List[Any]) -> str:
        """Format workflow steps for reporting."""
        step_lines = []
        
        for i, step in enumerate(steps, 1):
            status_icon = {
                "completed": "✅",
                "failed": "❌",
                "running": "🔄",
                "pending": "⏳",
                "skipped": "⏭️"
            }.get(step.status.value, "❓")
            
            duration = ""
            if step.start_time and step.end_time:
                duration = f" ({step.end_time - step.start_time:.1f}s)"
            
            step_lines.append(f"{i}. {status_icon} **{step.agent}.{step.action}**{duration}")
            
            if step.error:
                step_lines.append(f"   - Error: {step.error}")
        
        return "\n".join(step_lines)
    
    def _format_workflow_results(self, results: Dict[str, Any]) -> str:
        """Format workflow results."""
        if not results:
            return "No results available."
        
        result_lines = []
        for key, value in results.items():
            if isinstance(value, dict) and "success" in value:
                success_icon = "✅" if value["success"] else "❌"
                result_lines.append(f"- {success_icon} **{key}**: {value.get('message', 'Completed')}")
            else:
                result_lines.append(f"- **{key}**: Available")
        
        return "\n".join(result_lines)
    
    def _format_qa_reports(self, qa_reports: List[Dict[str, Any]]) -> str:
        """Format QA reports."""
        if not qa_reports:
            return "No QA reports available."
        
        passed = sum(1 for report in qa_reports if report.get("passed", False))
        total = len(qa_reports)
        
        qa_lines = [
            f"**QA Summary**: {passed}/{total} checks passed",
            ""
        ]
        
        for i, report in enumerate(qa_reports, 1):
            status = "✅ Passed" if report.get("passed", False) else "❌ Failed"
            qa_lines.append(f"{i}. {status}")
            
            if report.get("errors"):
                for error in report["errors"]:
                    qa_lines.append(f"   - Error: {error}")
            
            if report.get("warnings"):
                for warning in report["warnings"]:
                    qa_lines.append(f"   - Warning: {warning}")
        
        return "\n".join(qa_lines)
    
    def _format_errors_warnings(self, workflow_execution: Any) -> str:
        """Format errors and warnings from workflow execution."""
        issues = []
        
        # Collect errors from steps
        for step in workflow_execution.steps:
            if step.error:
                issues.append(f"❌ **{step.agent}.{step.action}**: {step.error}")
        
        # Collect warnings from QA reports
        for report in workflow_execution.qa_reports:
            for warning in report.get("warnings", []):
                issues.append(f"⚠️ **Warning**: {warning}")
        
        return "\n".join(issues) if issues else "No errors or warnings reported."
    
    def _format_entities_by_type(self, entities_by_type: Dict[str, int]) -> str:
        """Format entities by type."""
        if not entities_by_type:
            return "No entities found."
        
        lines = []
        for entity_type, count in sorted(entities_by_type.items()):
            lines.append(f"- **{entity_type}**: {count}")
        
        return "\n".join(lines)
    
    def _format_high_significance_entities(self, high_significance: List[Dict[str, Any]]) -> str:
        """Format high significance entities."""
        if not high_significance:
            return "No high-significance entities found."
        
        lines = []
        for entity in sorted(high_significance, key=lambda x: x["significance"], reverse=True):
            lines.append(f"- **{entity['name']}** ({entity['type']}) - Significance: {entity['significance']}")
        
        return "\n".join(lines)
    
    def _format_recent_entities(self, recent_entities: List[Dict[str, Any]]) -> str:
        """Format recent entities."""
        if not recent_entities:
            return "No recent entities found."
        
        lines = []
        for entity in sorted(recent_entities, key=lambda x: x["created_at"], reverse=True):
            lines.append(f"- **{entity['name']}** ({entity['type']}) - Created: {entity['created_at']}")
        
        return "\n".join(lines)
    
    # Event handlers
    async def _handle_generate_report(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Handle general report generation requests."""
        report_type = data.get("report_type", "analysis")
        
        if report_type == "analysis":
            return await self.generate_analysis_report(data.get("analysis_results", {}), data.get("metadata", {}))
        elif report_type == "entity_summary":
            return await self.generate_entity_summary()
        else:
            return {"success": False, "error": f"Unknown report type: {report_type}"}
    
    async def _handle_generate_analysis_doc(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Handle analysis document generation requests."""
        # Handle both analysis_results and analysis_result keys for compatibility
        analysis_results = data.get("analysis_results") or data.get("analysis_result", {})
        metadata = data.get("metadata", {})
        
        return await self.generate_analysis_report(analysis_results, metadata)
    
    async def _handle_generate_workflow_doc(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Handle workflow document generation requests."""
        workflow_execution = data["workflow_execution"]
        
        return await self.generate_workflow_report(workflow_execution)
    
    async def _handle_create_template(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Handle template creation requests."""
        template_name = data["template_name"]
        template_content = data["template_content"]
        
        try:
            template_path = self.template_dir / template_name
            with open(template_path, 'w') as f:
                f.write(template_content)
            
            return {
                "success": True,
                "template_name": template_name,
                "template_path": str(template_path)
            }
            
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    async def _handle_list_templates(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Handle template listing requests."""
        try:
            templates = []
            for template_file in self.template_dir.glob("*.md"):
                templates.append({
                    "name": template_file.name,
                    "path": str(template_file),
                    "size": template_file.stat().st_size
                })
            
            return {
                "success": True,
                "templates": templates,
                "template_dir": str(self.template_dir)
            }
            
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    # ========== NEW PLANTUML AND UKB INTEGRATION METHODS ==========
    
    async def _check_plantuml_availability(self):
        """Check if PlantUML is available on the system."""
        try:
            result = await asyncio.create_subprocess_exec(
                "plantuml", "-version",
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            await result.communicate()
            
            if result.returncode == 0:
                self.logger.info("PlantUML is available")
                self.plantuml_available = True
            else:
                self.logger.warning("PlantUML not available - diagram generation will be disabled")
                self.plantuml_available = False
                
        except Exception as e:
            self.logger.warning(f"Could not check PlantUML availability: {e}")
            self.plantuml_available = False
    
    async def generate_plantuml_diagram(self, diagram_type: str, content: str, name: str, analysis_result: Dict[str, Any] = None) -> Dict[str, Any]:
        """Generate a PlantUML diagram from content."""
        try:
            if not self.plantuml_available:
                return {"success": False, "error": "PlantUML not available"}
            
            # Ensure analysis_result is a dict
            if analysis_result is None:
                analysis_result = {}
            
            # Generate diagram content based on type
            puml_content = await self._generate_diagram_content(diagram_type, content, analysis_result)
            
            # Create filename
            safe_name = re.sub(r'[^a-zA-Z0-9_-]', '_', name.lower())
            puml_filename = f"{safe_name}-{diagram_type}.puml"
            puml_path = self.puml_dir / puml_filename
            
            # Save PlantUML file
            with open(puml_path, 'w') as f:
                f.write(puml_content)
            
            self.logger.info(f"Generated PlantUML diagram: {puml_filename}")
            
            return {
                "success": True,
                "puml_file": str(puml_path),
                "puml_filename": puml_filename,
                "diagram_type": diagram_type,
                "content": puml_content
            }
            
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    async def convert_puml_to_png(self, puml_file: str) -> Dict[str, Any]:
        """Convert PlantUML file to PNG image."""
        try:
            if not self.plantuml_available:
                return {"success": False, "error": "PlantUML not available"}
            
            puml_path = Path(puml_file)
            if not puml_path.exists():
                return {"success": False, "error": f"PlantUML file not found: {puml_file}"}
            
            # Output PNG to images directory
            png_filename = puml_path.stem + ".png"
            png_path = self.images_dir / png_filename
            
            # Run PlantUML to generate PNG
            result = await asyncio.create_subprocess_exec(
                "plantuml", "-tpng", "-o", str(self.images_dir), str(puml_path),
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await result.communicate()
            
            if result.returncode == 0 and png_path.exists():
                self.logger.info(f"Generated PNG: {png_filename}")
                return {
                    "success": True,
                    "png_file": str(png_path),
                    "png_filename": png_filename
                }
            else:
                error_msg = stderr.decode() if stderr else "Unknown PlantUML error"
                return {"success": False, "error": f"PlantUML conversion failed: {error_msg}"}
                
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    async def _generate_diagram_content(self, diagram_type: str, content: str, analysis_result: Dict[str, Any] = None) -> str:
        """Generate PlantUML diagram content based on type."""
        
        # Include standard styling
        style_include = f"!include {self.standard_style_path.resolve()}"
        
        if diagram_type == "architecture":
            return f"""@startuml architecture
{style_include}
title {content} - Architecture

' Auto-generated architecture diagram
package "Core System" {{
  component "Analysis Engine" <<core>>
  component "Knowledge Graph" <<storage>>
  component "Documentation" <<util>>
}}

package "Agents" {{
  component "Coordinator" <<agent>>
  component "Semantic Analysis" <<agent>>
  component "Documentation" <<agent>>
}}

package "External" {{
  component "UKB System" <<external>>
  component "PlantUML" <<external>>
}}

[Analysis Engine] --> [Knowledge Graph] : stores
[Documentation] --> [PlantUML] : generates
[Knowledge Graph] --> [UKB System] : syncs

@enduml"""
        
        elif diagram_type == "sequence":
            return f"""@startuml sequence
{style_include}
title {content} - Workflow Sequence

actor User
participant "Coordinator" as coord
participant "SemanticAnalysis" as semantic
participant "KnowledgeGraph" as kg
participant "Documentation" as doc

User -> coord : execute_workflow
coord -> semantic : analyze_repository
semantic -> kg : create_entities
kg -> doc : generate_documentation
doc -> coord : documentation_complete
coord -> User : workflow_result

@enduml"""
        
        elif diagram_type == "use-cases":
            return f"""@startuml use-cases
{style_include}
title {content} - Use Cases

left to right direction

actor "Developer" as dev
actor "Team Lead" as lead

rectangle "Semantic Analysis System" {{
  usecase "Analyze Repository" as analyze
  usecase "Generate Insights" as insights
  usecase "Update Knowledge" as update
  usecase "Generate Documentation" as docs
}}

dev --> analyze
dev --> insights
lead --> update
lead --> docs

analyze .> insights : includes
insights .> update : includes
update .> docs : includes

@enduml"""
        
        elif diagram_type == "class":
            return f"""@startuml class
{style_include}
title {content} - Class Structure

class BaseAgent {{
  +name: str
  +config: Dict
  +initialize()
  +shutdown()
  +health_check()
}}

class DocumentationAgent {{
  +generate_plantuml_diagram()
  +convert_puml_to_png()
  +create_insight_document()
}}

class KnowledgeGraphAgent {{
  +create_entity()
  +search_entities()
  +merge_entities()
}}

class CoordinatorAgent {{
  +execute_workflow()
  +validate_output()
}}

BaseAgent <|-- DocumentationAgent
BaseAgent <|-- KnowledgeGraphAgent
BaseAgent <|-- CoordinatorAgent

@enduml"""
        
        else:
            # Default diagram
            return f"""@startuml default
{style_include}
title {content} - System Overview

note as N1
  Generated from semantic analysis
  Content: {content[:100]}...
end note

@enduml"""
    
    async def create_insight_document(self, analysis_result: Dict[str, Any], metadata: Dict[str, Any] = None) -> Dict[str, Any]:
        """Create a comprehensive insight document with PlantUML diagrams."""
        try:
            metadata = metadata or {}
            
            # Generate insight name and filename
            insight_name = metadata.get("insight_name") or self._generate_insight_name(analysis_result)
            safe_name = re.sub(r'[^a-zA-Z0-9_-]', '', insight_name.replace(' ', ''))
            
            # Generate PlantUML diagrams
            diagrams = []
            diagram_types = ["architecture", "sequence", "use-cases", "class"]
            
            for diagram_type in diagram_types:
                diagram_result = await self.generate_plantuml_diagram(
                    diagram_type, insight_name, safe_name, analysis_result
                )
                
                if diagram_result["success"]:
                    # Convert to PNG
                    png_result = await self.convert_puml_to_png(diagram_result["puml_file"])
                    if png_result["success"]:
                        diagrams.append({
                            "type": diagram_type,
                            "puml_file": diagram_result["puml_filename"],
                            "png_file": png_result["png_filename"]
                        })
            
            # Generate insight document content
            insight_content = await self._generate_insight_content(
                insight_name, analysis_result, diagrams, metadata
            )
            
            # Save insight document
            insight_filename = f"{safe_name}.md"
            insight_path = self.insights_dir / insight_filename
            
            with open(insight_path, 'w') as f:
                f.write(insight_content)
            
            self.logger.info(f"Generated insight document: {insight_filename}")
            
            return {
                "success": True,
                "insight_file": str(insight_path),
                "insight_filename": insight_filename,
                "insight_name": insight_name,
                "diagrams": diagrams
            }
            
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    async def _generate_insight_content(self, insight_name: str, analysis_result: Dict[str, Any], 
                                      diagrams: List[Dict[str, Any]], metadata: Dict[str, Any]) -> str:
        """Generate the content for an insight document."""
        
        # Generate table of contents
        toc = """## Table of Contents
- [Overview](#overview)
- [Architecture](#architecture)
- [Implementation](#implementation)
- [Workflow Sequence](#workflow-sequence)
- [Use Cases](#use-cases)
- [Technical Details](#technical-details)
"""
        
        # Generate diagram sections
        diagram_sections = ""
        for diagram in diagrams:
            diagram_type = diagram["type"]
            png_file = diagram["png_file"]
            section_title = diagram_type.replace("-", " ").title()
            
            diagram_sections += f"""
## {section_title}

![{section_title} Diagram](images/{png_file})

{self._generate_diagram_description(diagram_type, analysis_result)}
"""
        
        # Generate main content
        overview = self._extract_overview(analysis_result)
        technical_details = self._extract_technical_details(analysis_result, metadata)
        
        content = f"""# {insight_name}

{toc}

## Overview

{overview}

{diagram_sections}

## Technical Details

{technical_details}

---
*Generated by Semantic Analysis Documentation Agent*  
*Date: {time.strftime("%Y-%m-%d %H:%M:%S")}*
"""
        
        return content
    
    def _generate_insight_name(self, analysis_result: Dict[str, Any]) -> str:
        """Generate an insight name from analysis results."""
        # Try to extract meaningful name from analysis
        if "result" in analysis_result and isinstance(analysis_result["result"], dict):
            result = analysis_result["result"]
            if "analysis" in result:
                # Extract first significant line
                lines = result["analysis"].split('\n')
                for line in lines:
                    if line.strip() and len(line.strip()) > 10:
                        # Clean and shorten
                        name = line.strip()[:50]
                        return re.sub(r'[^\w\s-]', '', name).title()
        
        # Fallback to timestamp-based name
        return f"SemanticAnalysis_{int(time.time())}"
    
    def _extract_overview(self, analysis_result: Dict[str, Any]) -> str:
        """Extract overview content from analysis results."""
        if "result" in analysis_result and isinstance(analysis_result["result"], dict):
            result = analysis_result["result"]
            if "analysis" in result:
                # Extract first paragraph
                text = result["analysis"]
                paragraphs = text.split('\n\n')
                if paragraphs:
                    return paragraphs[0][:500] + ("..." if len(paragraphs[0]) > 500 else "")
        
        return "Comprehensive analysis of codebase patterns and architectural insights."
    
    def _extract_technical_details(self, analysis_result: Dict[str, Any], metadata: Dict[str, Any]) -> str:
        """Extract technical details from analysis results."""
        details = []
        
        if "significance" in analysis_result:
            details.append(f"- **Significance**: {analysis_result['significance']}")
        
        if metadata.get("entity_count"):
            details.append(f"- **Entities Created**: {metadata['entity_count']}")
        
        if metadata.get("duration"):
            details.append(f"- **Analysis Duration**: {metadata['duration']}")
        
        if metadata.get("repository"):
            details.append(f"- **Repository**: {metadata['repository']}")
        
        details.append(f"- **Analysis Date**: {time.strftime('%Y-%m-%d %H:%M:%S')}")
        details.append(f"- **Agent**: Semantic Analysis Documentation Agent")
        
        return '\n'.join(details)
    
    def _generate_diagram_description(self, diagram_type: str, analysis_result: Dict[str, Any]) -> str:
        """Generate description for diagram sections."""
        descriptions = {
            "architecture": "The architecture diagram shows the high-level system components and their relationships, illustrating how different agents interact within the semantic analysis system.",
            "sequence": "The sequence diagram depicts the workflow execution flow, showing the interaction between components during a typical semantic analysis operation.",
            "use-cases": "The use case diagram illustrates the different ways users can interact with the semantic analysis system and the relationships between various use cases.",
            "class": "The class diagram shows the object-oriented structure of the system, including inheritance relationships and key methods of the main agent classes."
        }
        
        return descriptions.get(diagram_type, f"This {diagram_type} diagram provides additional insight into the system structure.")
    
    async def create_ukb_entity_with_insight(self, analysis_result: Dict[str, Any], metadata: Dict[str, Any] = None) -> Dict[str, Any]:
        """Create a UKB entity with a link to a detailed insight document."""
        try:
            # First create the insight document
            insight_result = await self.create_insight_document(analysis_result, metadata)
            
            if not insight_result["success"]:
                return {"success": False, "error": f"Failed to create insight document: {insight_result['error']}"}
            
            # Extract entity information
            insight_name = insight_result["insight_name"]
            insight_filename = insight_result["insight_filename"]
            
            # Create short observation for UKB entity
            short_observation = self._generate_short_observation(analysis_result, metadata)
            
            # Create UKB entity with insight link
            entity_data = {
                "name": insight_name,
                "entityType": metadata.get("entity_type", "SemanticInsight"),
                "significance": analysis_result.get("significance", 7),
                "observations": [
                    short_observation,
                    f"Details: insights/{insight_filename}"
                ]
            }
            
            # Execute UKB command to create entity
            ukb_result = await self._execute_ukb_command("--add-entity", entity_data)
            
            return {
                "success": True,
                "entity_name": insight_name,
                "insight_document": insight_result,
                "ukb_result": ukb_result
            }
            
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    def _generate_short_observation(self, analysis_result: Dict[str, Any], metadata: Dict[str, Any]) -> str:
        """Generate a short observation for the UKB entity."""
        # Extract key insight in one sentence
        overview = self._extract_overview(analysis_result)
        # Take first sentence or first 150 characters
        first_sentence = overview.split('.')[0]
        if len(first_sentence) > 150:
            first_sentence = first_sentence[:150] + "..."
        
        return first_sentence + "."
    
    async def _execute_ukb_command(self, command: str, data: Dict[str, Any] = None) -> Dict[str, Any]:
        """Execute UKB command with data."""
        try:
            if data:
                # Create temporary file for data
                import tempfile
                import json
                
                with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
                    json.dump(data, f, indent=2)
                    temp_file = f.name
                
                try:
                    # Execute UKB command using interactive mode with input data
                    if command == "--interactive":
                        with open(temp_file, 'r') as f:
                            input_data = f.read()
                        result = await asyncio.create_subprocess_exec(
                            self.ukb_command, "--interactive",
                            stdin=asyncio.subprocess.PIPE,
                            stdout=asyncio.subprocess.PIPE,
                            stderr=asyncio.subprocess.PIPE
                        )
                        stdout, stderr = await result.communicate(input=input_data.encode())
                    else:
                        # For other commands, use direct execution
                        result = await asyncio.create_subprocess_exec(
                            self.ukb_command, command,
                            stdout=asyncio.subprocess.PIPE,
                            stderr=asyncio.subprocess.PIPE
                        )
                        stdout, stderr = await result.communicate()
                    
                    return {
                        "success": result.returncode == 0,
                        "output": stdout.decode() if stdout else "",
                        "error": stderr.decode() if stderr else ""
                    }
                    
                finally:
                    # Clean up temp file
                    try:
                        os.unlink(temp_file)
                    except:
                        pass
            else:
                # Execute UKB command without data
                result = await asyncio.create_subprocess_exec(
                    self.ukb_command, command,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                
                stdout, stderr = await result.communicate()
                
                return {
                    "success": result.returncode == 0,
                    "output": stdout.decode() if stdout else "",
                    "error": stderr.decode() if stderr else ""
                }
                
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    # ========== EVENT HANDLERS FOR NEW CAPABILITIES ==========
    
    async def _handle_generate_plantuml_diagram(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Handle PlantUML diagram generation requests."""
        try:
            # Ensure data is not None and has required fields
            if not data or not isinstance(data, dict):
                return {"success": False, "error": "Invalid data provided"}
            
            diagram_type = data.get("diagram_type", "architecture")
            content = data.get("content", "Unknown")
            name = data.get("name", "diagram")
            analysis_result = data.get("analysis_result", {})
            
            # Ensure analysis_result is a dict
            if analysis_result is None:
                analysis_result = {}
            
            return await self.generate_plantuml_diagram(
                diagram_type=diagram_type,
                content=content,
                name=name,
                analysis_result=analysis_result
            )
        except Exception as e:
            return {"success": False, "error": f"PlantUML generation handler error: {str(e)}"}
    
    async def _handle_convert_puml_to_png(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Handle PlantUML to PNG conversion requests."""
        return await self.convert_puml_to_png(data["puml_file"])
    
    async def _handle_create_insight_document(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Handle insight document creation requests."""
        return await self.create_insight_document(
            analysis_result=data["analysis_result"],
            metadata=data.get("metadata")
        )
    
    async def _handle_create_ukb_entity_with_insight(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Handle UKB entity creation with insight document."""
        return await self.create_ukb_entity_with_insight(
            analysis_result=data["analysis_result"],
            metadata=data.get("metadata")
        )
    
    async def _handle_generate_lessons_learned(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Handle lessons learned generation (specialized insight document)."""
        # Add lessons learned specific metadata
        metadata = data.get("metadata", {})
        metadata["entity_type"] = "LessonsLearned"
        metadata["insight_name"] = data.get("title", "Lessons Learned")
        
        return await self.create_ukb_entity_with_insight(
            analysis_result=data["analysis_result"],
            metadata=metadata
        )
    
    async def health_check(self) -> Dict[str, Any]:
        """Check documentation agent health."""
        base_health = await super().health_check()
        
        template_count = len(list(self.template_dir.glob("*.md"))) if self.template_dir.exists() else 0
        
        return {
            **base_health,
            "template_dir": str(self.template_dir),
            "template_count": template_count,
            "output_format": self.output_format,
            "auto_generation_enabled": self.auto_generation_config.get("on_workflow_completion", False),
            "plantuml_available": getattr(self, 'plantuml_available', False),
            "insights_dir": str(self.insights_dir),
            "puml_dir": str(self.puml_dir),
            "images_dir": str(self.images_dir),
            "ukb_command": self.ukb_command
        }