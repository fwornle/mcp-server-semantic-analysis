"""
Documentation Agent
Handles automated documentation generation and template management
"""

import asyncio
import json
import os
from pathlib import Path
from typing import Dict, Any, List, Optional
import time
from string import Template

from .base import BaseAgent


class DocumentationAgent(BaseAgent):
    """Agent for generating documentation from analysis results."""
    
    def __init__(self, name: str, config: Dict[str, Any], system: Any):
        super().__init__(name, config, system)
        
        self.generation_config = config.get("generation", {})
        self.auto_generation_config = config.get("auto_generation", {})
        self.template_dir = Path(self.generation_config.get("template_dir", "templates"))
        self.output_format = self.generation_config.get("output_format", "markdown")
        
        self.register_capability("document_generation")
        self.register_capability("template_management")
        self.register_capability("auto_documentation")
    
    async def on_initialize(self):
        """Initialize documentation agent."""
        self.logger.info("Initializing documentation agent...")
        
        # Create template directory if it doesn't exist
        self.template_dir.mkdir(parents=True, exist_ok=True)
        
        # Create default templates
        await self._create_default_templates()
        
        self._register_event_handlers()
    
    def _register_event_handlers(self):
        """Register event handlers."""
        self.register_event_handler("generate_report", self._handle_generate_report)
        self.register_event_handler("generate_analysis_doc", self._handle_generate_analysis_doc)
        self.register_event_handler("generate_workflow_doc", self._handle_generate_workflow_doc)
        self.register_event_handler("create_template", self._handle_create_template)
        self.register_event_handler("list_templates", self._handle_list_templates)
    
    async def _create_default_templates(self):
        """Create default documentation templates."""
        templates = {
            "analysis_report.md": """# Semantic Analysis Report

**Generated**: ${timestamp}
**Repository**: ${repository}
**Analysis Type**: ${analysis_type}

## Summary

${summary}

## Key Findings

${findings}

## Entities Created

${entities_summary}

## Recommendations

${recommendations}

## Technical Details

- **Duration**: ${duration}
- **Entities Processed**: ${entity_count}
- **Significance Threshold**: ${significance_threshold}
- **Agent**: ${agent_name}

---
*Generated by Semantic Analysis System*
""",
            
            "workflow_report.md": """# Workflow Execution Report

**Workflow**: ${workflow_name}
**Status**: ${status}
**Duration**: ${duration}
**Completed**: ${timestamp}

## Workflow Steps

${steps_summary}

## Results Summary

${results_summary}

## Quality Assurance

${qa_summary}

## Errors and Warnings

${errors_warnings}

---
*Generated automatically by Coordinator Agent*
""",
            
            "entity_summary.md": """# Entity Summary Report

**Generated**: ${timestamp}
**Total Entities**: ${total_entities}

## Entities by Type

${entities_by_type}

## High Significance Entities

${high_significance_entities}

## Recent Entities

${recent_entities}

---
*Generated by Knowledge Graph Agent*
"""
        }
        
        for template_name, content in templates.items():
            template_path = self.template_dir / template_name
            if not template_path.exists():
                with open(template_path, 'w') as f:
                    f.write(content)
                self.logger.debug(f"Created default template: {template_name}")
    
    async def generate_analysis_report(self, analysis_results: Dict[str, Any], metadata: Dict[str, Any] = None) -> Dict[str, Any]:
        """Generate a comprehensive analysis report."""
        metadata = metadata or {}
        
        try:
            # Prepare template variables
            template_vars = {
                "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
                "repository": metadata.get("repository", "Unknown"),
                "analysis_type": metadata.get("analysis_type", "General"),
                "summary": self._generate_summary(analysis_results),
                "findings": self._format_findings(analysis_results),
                "entities_summary": self._format_entities_summary(analysis_results),
                "recommendations": self._generate_recommendations(analysis_results),
                "duration": metadata.get("duration", "Unknown"),
                "entity_count": metadata.get("entity_count", 0),
                "significance_threshold": metadata.get("significance_threshold", 5),
                "agent_name": "Semantic Analysis Agent"
            }
            
            # Generate document using template
            document = await self._apply_template("analysis_report.md", template_vars)
            
            # Save document if requested
            output_path = None
            if metadata.get("save_to_file"):
                output_path = await self._save_document(document, f"analysis_report_{int(time.time())}.md")
            
            return {
                "success": True,
                "document": document,
                "output_path": output_path,
                "template_used": "analysis_report.md"
            }
            
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    async def generate_workflow_report(self, workflow_execution: Any) -> Dict[str, Any]:
        """Generate a workflow execution report."""
        try:
            # Extract workflow information
            steps_summary = self._format_workflow_steps(workflow_execution.steps)
            results_summary = self._format_workflow_results(workflow_execution.results)
            qa_summary = self._format_qa_reports(workflow_execution.qa_reports)
            errors_warnings = self._format_errors_warnings(workflow_execution)
            
            template_vars = {
                "workflow_name": workflow_execution.name,
                "status": workflow_execution.status.value,
                "duration": f"{workflow_execution.end_time - workflow_execution.start_time:.1f}s" if workflow_execution.end_time else "Running",
                "timestamp": time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(workflow_execution.end_time)) if workflow_execution.end_time else "In Progress",
                "steps_summary": steps_summary,
                "results_summary": results_summary,
                "qa_summary": qa_summary,
                "errors_warnings": errors_warnings
            }
            
            document = await self._apply_template("workflow_report.md", template_vars)
            
            return {
                "success": True,
                "document": document,
                "workflow_id": workflow_execution.id,
                "template_used": "workflow_report.md"
            }
            
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    async def generate_entity_summary(self) -> Dict[str, Any]:
        """Generate a summary of all entities in the knowledge graph."""
        try:
            kg_agent = self.system.agents.get("knowledge_graph")
            if not kg_agent:
                return {"success": False, "error": "Knowledge graph agent not available"}
            
            entities = kg_agent.entities
            
            # Analyze entities
            entities_by_type = {}
            high_significance = []
            recent_entities = []
            
            current_time = time.time()
            
            for entity in entities.values():
                # Group by type
                entity_type = entity.entity_type
                if entity_type not in entities_by_type:
                    entities_by_type[entity_type] = 0
                entities_by_type[entity_type] += 1
                
                # High significance entities
                if entity.significance >= 8:
                    high_significance.append({
                        "name": entity.name,
                        "type": entity.entity_type,
                        "significance": entity.significance
                    })
                
                # Recent entities (last 24 hours)
                if current_time - entity.created_at < 86400:
                    recent_entities.append({
                        "name": entity.name,
                        "type": entity.entity_type,
                        "created_at": time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(entity.created_at))
                    })
            
            template_vars = {
                "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
                "total_entities": len(entities),
                "entities_by_type": self._format_entities_by_type(entities_by_type),
                "high_significance_entities": self._format_high_significance_entities(high_significance),
                "recent_entities": self._format_recent_entities(recent_entities)
            }
            
            document = await self._apply_template("entity_summary.md", template_vars)
            
            return {
                "success": True,
                "document": document,
                "statistics": {
                    "total_entities": len(entities),
                    "entity_types": len(entities_by_type),
                    "high_significance_count": len(high_significance),
                    "recent_count": len(recent_entities)
                }
            }
            
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    async def _apply_template(self, template_name: str, variables: Dict[str, Any]) -> str:
        """Apply template with variables."""
        template_path = self.template_dir / template_name
        
        if not template_path.exists():
            raise ValueError(f"Template not found: {template_name}")
        
        with open(template_path, 'r') as f:
            template_content = f.read()
        
        template = Template(template_content)
        return template.safe_substitute(variables)
    
    async def _save_document(self, document: str, filename: str) -> str:
        """Save document to file."""
        output_dir = Path(__file__).parent.parent / "reports"
        output_dir.mkdir(exist_ok=True)
        
        output_path = output_dir / filename
        with open(output_path, 'w') as f:
            f.write(document)
        
        return str(output_path)
    
    def _generate_summary(self, analysis_results: Dict[str, Any]) -> str:
        """Generate a summary from analysis results."""
        if "result" in analysis_results:
            result = analysis_results["result"]
            if isinstance(result, dict) and "analysis" in result:
                analysis_text = result["analysis"]
                # Extract first paragraph or first 200 characters
                lines = analysis_text.split('\n')
                first_paragraph = lines[0] if lines else analysis_text
                return first_paragraph[:200] + "..." if len(first_paragraph) > 200 else first_paragraph
        
        return "Analysis completed successfully with semantic insights extracted."
    
    def _format_findings(self, analysis_results: Dict[str, Any]) -> str:
        """Format key findings from analysis results."""
        findings = []
        
        if "result" in analysis_results:
            result = analysis_results["result"]
            if isinstance(result, dict):
                if "structured" in result and result["structured"]:
                    for key, value in result["structured"].items():
                        findings.append(f"- **{key.replace('_', ' ').title()}**: {value}")
                
                if "patterns" in result:
                    findings.append("- **Patterns Detected**: " + ", ".join(p.get("type", "Unknown") for p in result["patterns"]))
        
        return "\n".join(findings) if findings else "No specific findings available."
    
    def _format_entities_summary(self, analysis_results: Dict[str, Any]) -> str:
        """Format entities summary."""
        return f"Entities created during this analysis session. See Knowledge Graph for details."
    
    def _generate_recommendations(self, analysis_results: Dict[str, Any]) -> str:
        """Generate recommendations based on analysis results."""
        recommendations = [
            "Review high-significance patterns for potential architecture improvements",
            "Consider implementing identified best practices across the codebase",
            "Monitor entities with low significance scores for potential consolidation"
        ]
        
        return "\n".join(f"- {rec}" for rec in recommendations)
    
    def _format_workflow_steps(self, steps: List[Any]) -> str:
        """Format workflow steps for reporting."""
        step_lines = []
        
        for i, step in enumerate(steps, 1):
            status_icon = {
                "completed": "✅",
                "failed": "❌",
                "running": "🔄",
                "pending": "⏳",
                "skipped": "⏭️"
            }.get(step.status.value, "❓")
            
            duration = ""
            if step.start_time and step.end_time:
                duration = f" ({step.end_time - step.start_time:.1f}s)"
            
            step_lines.append(f"{i}. {status_icon} **{step.agent}.{step.action}**{duration}")
            
            if step.error:
                step_lines.append(f"   - Error: {step.error}")
        
        return "\n".join(step_lines)
    
    def _format_workflow_results(self, results: Dict[str, Any]) -> str:
        """Format workflow results."""
        if not results:
            return "No results available."
        
        result_lines = []
        for key, value in results.items():
            if isinstance(value, dict) and "success" in value:
                success_icon = "✅" if value["success"] else "❌"
                result_lines.append(f"- {success_icon} **{key}**: {value.get('message', 'Completed')}")
            else:
                result_lines.append(f"- **{key}**: Available")
        
        return "\n".join(result_lines)
    
    def _format_qa_reports(self, qa_reports: List[Dict[str, Any]]) -> str:
        """Format QA reports."""
        if not qa_reports:
            return "No QA reports available."
        
        passed = sum(1 for report in qa_reports if report.get("passed", False))
        total = len(qa_reports)
        
        qa_lines = [
            f"**QA Summary**: {passed}/{total} checks passed",
            ""
        ]
        
        for i, report in enumerate(qa_reports, 1):
            status = "✅ Passed" if report.get("passed", False) else "❌ Failed"
            qa_lines.append(f"{i}. {status}")
            
            if report.get("errors"):
                for error in report["errors"]:
                    qa_lines.append(f"   - Error: {error}")
            
            if report.get("warnings"):
                for warning in report["warnings"]:
                    qa_lines.append(f"   - Warning: {warning}")
        
        return "\n".join(qa_lines)
    
    def _format_errors_warnings(self, workflow_execution: Any) -> str:
        """Format errors and warnings from workflow execution."""
        issues = []
        
        # Collect errors from steps
        for step in workflow_execution.steps:
            if step.error:
                issues.append(f"❌ **{step.agent}.{step.action}**: {step.error}")
        
        # Collect warnings from QA reports
        for report in workflow_execution.qa_reports:
            for warning in report.get("warnings", []):
                issues.append(f"⚠️ **Warning**: {warning}")
        
        return "\n".join(issues) if issues else "No errors or warnings reported."
    
    def _format_entities_by_type(self, entities_by_type: Dict[str, int]) -> str:
        """Format entities by type."""
        if not entities_by_type:
            return "No entities found."
        
        lines = []
        for entity_type, count in sorted(entities_by_type.items()):
            lines.append(f"- **{entity_type}**: {count}")
        
        return "\n".join(lines)
    
    def _format_high_significance_entities(self, high_significance: List[Dict[str, Any]]) -> str:
        """Format high significance entities."""
        if not high_significance:
            return "No high-significance entities found."
        
        lines = []
        for entity in sorted(high_significance, key=lambda x: x["significance"], reverse=True):
            lines.append(f"- **{entity['name']}** ({entity['type']}) - Significance: {entity['significance']}")
        
        return "\n".join(lines)
    
    def _format_recent_entities(self, recent_entities: List[Dict[str, Any]]) -> str:
        """Format recent entities."""
        if not recent_entities:
            return "No recent entities found."
        
        lines = []
        for entity in sorted(recent_entities, key=lambda x: x["created_at"], reverse=True):
            lines.append(f"- **{entity['name']}** ({entity['type']}) - Created: {entity['created_at']}")
        
        return "\n".join(lines)
    
    # Event handlers
    async def _handle_generate_report(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Handle general report generation requests."""
        report_type = data.get("report_type", "analysis")
        
        if report_type == "analysis":
            return await self.generate_analysis_report(data.get("analysis_results", {}), data.get("metadata", {}))
        elif report_type == "entity_summary":
            return await self.generate_entity_summary()
        else:
            return {"success": False, "error": f"Unknown report type: {report_type}"}
    
    async def _handle_generate_analysis_doc(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Handle analysis document generation requests."""
        analysis_results = data["analysis_results"]
        metadata = data.get("metadata", {})
        
        return await self.generate_analysis_report(analysis_results, metadata)
    
    async def _handle_generate_workflow_doc(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Handle workflow document generation requests."""
        workflow_execution = data["workflow_execution"]
        
        return await self.generate_workflow_report(workflow_execution)
    
    async def _handle_create_template(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Handle template creation requests."""
        template_name = data["template_name"]
        template_content = data["template_content"]
        
        try:
            template_path = self.template_dir / template_name
            with open(template_path, 'w') as f:
                f.write(template_content)
            
            return {
                "success": True,
                "template_name": template_name,
                "template_path": str(template_path)
            }
            
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    async def _handle_list_templates(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Handle template listing requests."""
        try:
            templates = []
            for template_file in self.template_dir.glob("*.md"):
                templates.append({
                    "name": template_file.name,
                    "path": str(template_file),
                    "size": template_file.stat().st_size
                })
            
            return {
                "success": True,
                "templates": templates,
                "template_dir": str(self.template_dir)
            }
            
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    async def health_check(self) -> Dict[str, Any]:
        """Check documentation agent health."""
        base_health = await super().health_check()
        
        template_count = len(list(self.template_dir.glob("*.md"))) if self.template_dir.exists() else 0
        
        return {
            **base_health,
            "template_dir": str(self.template_dir),
            "template_count": template_count,
            "output_format": self.output_format,
            "auto_generation_enabled": self.auto_generation_config.get("on_workflow_completion", False)
        }