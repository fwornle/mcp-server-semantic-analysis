# Batch Analysis Workflow - Chronological Batch Processing with Tree-KG Operators + CGR
# Processes git history in 50-commit batches, applying 6 operators per batch
# Includes Code Graph RAG for AST-based code intelligence and LLM synthesis
#
# ARCHITECTURE NOTE: CGR runs AFTER all batches complete because:
# - CGR indexes the CURRENT state of the codebase (HEAD)
# - Batch processing analyzes HISTORICAL commits (oldest to newest)
# - Running CGR per-batch would create temporal mismatch (old commits vs current code)
# - Solution: Process all batches first, then CGR indexes current state,
#   then correlate historical findings with current codebase to identify:
#   - Entities that still exist → enrich with CGR synthesis
#   - Entities that are historical → mark as superseded/deleted
#
# Version: 1.2

workflow:
  name: batch-analysis
  version: "1.2"
  description: "Chronological batch processing with Tree-KG operators and Code Graph RAG for incremental KG expansion"
  type: iterative  # Signals coordinator to use batch iteration

config:
  max_concurrent_steps: 2  # Limited concurrency for batch processing
  timeout_per_batch: 300   # 5 minutes per batch
  quality_validation: true
  batch_size: 50           # Commits per batch (overridable via params)
  max_batches: 0           # 0 = process all batches
  checkpoint_enabled: true # Enable per-batch checkpointing

# Parameters that can be passed to the workflow
parameters:
  repositoryPath:
    required: true
    description: "Path to the repository to analyze"
  team:
    required: true
    description: "Team name for knowledge graph storage"
  batchSize:
    default: 50
    description: "Number of commits per batch"
  maxBatches:
    default: 0
    description: "Maximum batches to process (0 = all)"
  resumeFromCheckpoint:
    default: true
    description: "Resume from last completed batch"
  fullAnalysis:
    default: false
    description: "When true, clear checkpoints and analyze all commits from beginning"
  operatorWeights:
    default:
      alpha: 0.6  # Semantic similarity weight
      beta: 0.2   # Adamic-Adar weight
      gamma: 0.2  # Common ancestors weight
    description: "Weights for edge prediction scoring"

# Workflow steps
steps:
  # PHASE 0: Plan Batches (runs once at start)
  - name: plan_batches
    agent: batch_scheduler
    action: planBatches
    parameters:
      repositoryPath: "{{params.repositoryPath}}"
      team: "{{params.team}}"
      batchSize: "{{params.batchSize}}"
      maxBatches: "{{params.maxBatches}}"
      resumeFromCheckpoint: "{{params.resumeFromCheckpoint}}"
      fullAnalysis: "{{params.fullAnalysis}}"
    timeout: 60
    dependencies: []
    phase: initialization

  # NOTE: CGR (Code Graph RAG) steps moved to FINALIZATION phase
  # See architecture note at top of file for rationale

  # --- BATCH LOOP BEGINS (steps with phase: batch are repeated per batch) ---

  # PHASE 1: Extract Batch Data
  - name: extract_batch_commits
    agent: git_history
    action: extractCommitsForBatch
    parameters:
      startCommit: "{{currentBatch.startCommit}}"
      endCommit: "{{currentBatch.endCommit}}"
    timeout: 60
    dependencies:
      - plan_batches
    phase: batch
    operator: extract

  - name: extract_batch_sessions
    agent: vibe_history
    action: extractSessionsForCommits
    parameters:
      commits: "{{extract_batch_commits.result.commits}}"
    timeout: 60
    dependencies:
      - extract_batch_commits
    phase: batch
    operator: extract

  # PHASE 2: Semantic Analysis for Batch (pure historical analysis - no CGR)
  # NOTE: CGR correlation happens in finalization phase after all batches complete
  - name: batch_semantic_analysis
    agent: semantic_analysis
    action: analyzeSemantics
    tier: premium  # Use high-quality model for semantic analysis
    parameters:
      git_commits: "{{extract_batch_commits.result.commits}}"
      vibe_sessions: "{{extract_batch_sessions.result.sessions}}"
      session_correlations: "{{extract_batch_sessions.result.correlations}}"
      batch_context:
        batchId: "{{currentBatch.id}}"
        startDate: "{{currentBatch.startDate}}"
        endDate: "{{currentBatch.endDate}}"
    timeout: 120
    dependencies:
      - extract_batch_commits
      - extract_batch_sessions
    phase: batch
    operator: analyze

  # PHASE 2.5: Ontology Classification (newly added)
  - name: classify_with_ontology
    agent: ontology_classification
    action: classifyObservations
    tier: standard
    parameters:
      observations: "{{batch_semantic_analysis.result.entities}}"
      autoExtend: true
      minConfidence: 0.6
    timeout: 120
    dependencies:
      - batch_semantic_analysis
    phase: batch
    operator: classify

  # PHASE 3: Tree-KG Operators (applied in sequence)
  - name: operator_conv
    agent: kg_operators
    action: contextConvolution
    tier: premium  # Context enrichment needs quality
    parameters:
      entities: "{{classify_with_ontology.result.classified}}"
      batchContext:
        batchId: "{{currentBatch.id}}"
        startDate: "{{currentBatch.startDate}}"
        endDate: "{{currentBatch.endDate}}"
        commits: "{{extract_batch_commits.result.commits}}"
        sessions: "{{extract_batch_sessions.result.sessions}}"
    timeout: 60
    dependencies:
      - classify_with_ontology
    phase: batch
    operator: conv

  - name: operator_aggr
    agent: kg_operators
    action: entityAggregation
    tier: standard
    parameters:
      entities: "{{operator_conv.result}}"
    timeout: 30
    dependencies:
      - operator_conv
    phase: batch
    operator: aggr

  - name: operator_embed
    agent: kg_operators
    action: nodeEmbedding
    tier: fast  # Just embedding API calls
    parameters:
      entities: "{{operator_aggr.result.core}}"
      nonCoreEntities: "{{operator_aggr.result.nonCore}}"
    timeout: 120
    dependencies:
      - operator_aggr
    phase: batch
    operator: embed

  - name: operator_dedup
    agent: kg_operators
    action: deduplication
    tier: standard
    parameters:
      entities: "{{operator_embed.result}}"
      accumulatedKG: "{{accumulatedKG}}"
    timeout: 60
    dependencies:
      - operator_embed
    phase: batch
    operator: dedup

  - name: operator_pred
    agent: kg_operators
    action: edgePrediction
    tier: premium  # Edge prediction needs reasoning
    parameters:
      entities: "{{operator_dedup.result.entities}}"
      accumulatedKG: "{{accumulatedKG}}"
      weights: "{{params.operatorWeights}}"
    timeout: 90
    dependencies:
      - operator_dedup
    phase: batch
    operator: pred

  - name: operator_merge
    agent: kg_operators
    action: structureMerge
    tier: standard
    parameters:
      batchResults:
        entities: "{{operator_dedup.result.entities}}"
        relations: "{{operator_pred.result.edges}}"
      accumulatedKG: "{{accumulatedKG}}"
    timeout: 30
    dependencies:
      - operator_pred
    phase: batch
    operator: merge

  # PHASE 4: Batch Quality Check
  - name: batch_qa
    agent: quality_assurance
    action: validateBatch
    tier: premium  # Accurate QA requires good model
    parameters:
      mergeResult: "{{operator_merge.result}}"
      batchId: "{{currentBatch.id}}"
    timeout: 60
    dependencies:
      - operator_merge
    phase: batch
    operator: qa

  # PHASE 5: Batch Checkpoint
  - name: save_batch_checkpoint
    agent: batch_checkpoint_manager
    action: saveBatchCheckpoint
    parameters:
      batchId: "{{currentBatch.id}}"
      batchNumber: "{{currentBatch.batchNumber}}"
      commitRange:
        start: "{{currentBatch.startCommit}}"
        end: "{{currentBatch.endCommit}}"
      dateRange:
        start: "{{currentBatch.startDate}}"
        end: "{{currentBatch.endDate}}"
      stats: "{{batch_qa.result.stats}}"
    timeout: 10
    dependencies:
      - batch_qa
    phase: batch
    operator: checkpoint

  # --- BATCH LOOP ENDS ---

  # ============================================================================
  # FINALIZATION PHASE: CGR + Correlation + Persistence
  # CGR runs HERE (after all batches) because it indexes CURRENT state,
  # which we then correlate with HISTORICAL batch findings
  # ============================================================================

  # PHASE F1: Code Graph RAG - Index Current Codebase
  # Indexes the current HEAD state of the repository
  - name: index_codebase
    agent: code_graph
    action: indexRepository
    parameters:
      target_path: "{{params.repositoryPath}}"
      forceReindex: "{{params.fullAnalysis}}"
      minNodeThreshold: 1000
    timeout: 600
    dependencies:
      - save_batch_checkpoint  # Wait for ALL batches to complete
    phase: finalization

  # PHASE F2: Code Graph RAG - LLM Synthesis
  # Generate insights about current codebase structure
  - name: synthesize_code_insights
    agent: code_graph
    action: synthesizeInsights
    tier: premium
    parameters:
      target_entities: ["Class", "Function"]
      depth: "full"
      limit: 30
    timeout: 300
    dependencies:
      - index_codebase
    phase: finalization

  # PHASE F3: Correlate Historical Findings with Current Codebase
  # This is the KEY step that resolves the temporal mismatch:
  # - Takes all entities discovered during batch processing (historical)
  # - Checks which ones still exist in current codebase (via CGR)
  # - Enriches existing entities with CGR synthesis insights
  # - Marks historical-only entities as superseded/deleted
  - name: correlate_with_codebase
    agent: code_graph
    action: correlateHistoricalFindings
    tier: premium
    parameters:
      # Historical entities from all batches
      accumulated_entities: "{{accumulatedKG.entities}}"
      # Current codebase structure from CGR
      codebase_index: "{{index_codebase.result}}"
      # LLM-generated insights about current code
      synthesis_insights: "{{synthesize_code_insights.result}}"
      # Correlation settings
      correlation_config:
        # Match by qualified name (exact)
        match_by_name: true
        # Also try fuzzy matching for renamed entities
        fuzzy_match_threshold: 0.8
        # Mark entities not found in current codebase
        mark_historical: true
        # Try to identify what replaced deleted entities
        track_evolution: true
    timeout: 180
    dependencies:
      - synthesize_code_insights
    phase: finalization

  # PHASE F4: Transform Code Entities (with correlation results)
  - name: transform_code_entities
    agent: code_graph
    action: transformToKnowledgeEntities
    parameters:
      codebase_analysis: "{{index_codebase.result}}"
      synthesis_results: "{{synthesize_code_insights.result}}"
      correlation_results: "{{correlate_with_codebase.result}}"
    timeout: 120
    dependencies:
      - correlate_with_codebase
    phase: finalization

  # PHASE F5: Final Persistence (runs once after all batches)
  - name: final_persist
    agent: persistence
    action: persistEntities
    parameters:
      entities: "{{accumulatedKG.entities}}"
      code_entities: "{{transform_code_entities.result}}"
      correlated_entities: "{{correlate_with_codebase.result.enriched}}"
      historical_entities: "{{correlate_with_codebase.result.historical}}"
      team: "{{params.team}}"
    timeout: 120
    dependencies:
      - transform_code_entities
    phase: finalization

  # PHASE 7: Final Deduplication
  - name: final_dedup
    agent: deduplication
    action: deduplicateEntities
    parameters:
      persisted_results: "{{final_persist.result}}"
    timeout: 180
    dependencies:
      - final_persist
    phase: finalization

  # PHASE 8: Content Validation
  - name: final_validation
    agent: content_validation
    action: validateAllEntities
    parameters:
      deduplicated_results: "{{final_dedup.result}}"
    timeout: 120
    dependencies:
      - final_dedup
    phase: finalization

# DAG visualization for batch workflow
# NOTE: CGR runs in FINALIZATION (after all batches), not initialization
# This avoids temporal mismatch between historical commits and current codebase
edges:
  # ========== INITIALIZATION PHASE ==========
  - from: orchestrator
    to: batch_scheduler
    type: control
    label: "plan batches"

  # ========== BATCH LOOP PHASE ==========
  # Batch extraction (parallel: both git and vibe receive batch info)
  - from: batch_scheduler
    to: git_history
    type: dataflow
    label: "per batch"

  - from: batch_scheduler
    to: vibe_history
    type: dataflow
    label: "per batch"

  # Data flow: vibe uses commits from git
  - from: git_history
    to: vibe_history
    type: dataflow
    label: "commits"

  # Semantic analysis (pure historical - NO CGR here)
  - from: git_history
    to: semantic_analysis
    type: dependency
  - from: vibe_history
    to: semantic_analysis
    type: dependency

  # Ontology classification
  - from: semantic_analysis
    to: ontology_classification
    type: dependency
    label: "classify"

  # Tree-KG operator pipeline
  - from: ontology_classification
    to: kg_operators
    type: dependency
    label: "conv"

  - from: kg_operators
    to: kg_operators
    type: self
    label: "conv→aggr→embed→dedup→pred→merge"

  # QA and checkpoint
  - from: kg_operators
    to: quality_assurance
    type: dependency

  - from: quality_assurance
    to: batch_checkpoint_manager
    type: dependency

  # Loop back for next batch
  - from: batch_checkpoint_manager
    to: git_history
    type: control
    label: "next batch"

  # ========== FINALIZATION PHASE ==========
  # CGR runs AFTER all batches complete (indexes current HEAD)
  - from: batch_checkpoint_manager
    to: code_graph
    type: dependency
    label: "index current"

  # CGR synthesis (LLM analysis of current codebase)
  - from: code_graph
    to: code_graph
    type: self
    label: "index→synthesize"

  # Correlation: match historical batch entities with current codebase
  - from: code_graph
    to: correlation
    type: dependency
    label: "correlate"

  # Correlation also needs accumulated batch results
  - from: batch_checkpoint_manager
    to: correlation
    type: dataflow
    label: "historical entities"

  # Transform code entities (with correlation enrichment)
  - from: correlation
    to: code_graph
    type: dependency
    label: "transform"

  # Persistence (receives both batch entities and code entities)
  - from: code_graph
    to: persistence
    type: dependency
    label: "code entities"

  - from: correlation
    to: persistence
    type: dependency
    label: "enriched + historical"

  - from: persistence
    to: deduplication
    type: dependency

  - from: deduplication
    to: content_validation
    type: dependency

# Operator tier assignments (for coordinator reference)
operator_tiers:
  conv: premium
  aggr: standard
  embed: fast
  dedup: standard
  pred: premium
  merge: standard
  qa: premium
