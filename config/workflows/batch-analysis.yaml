# Batch Analysis Workflow - Chronological Batch Processing with Tree-KG Operators + CGR
# Processes git history in 50-commit batches, applying 6 operators per batch
# Includes Code Graph RAG for AST-based code intelligence and LLM synthesis
#
# ARCHITECTURE NOTE: CGR runs AFTER all batches complete because:
# - CGR indexes the CURRENT state of the codebase (HEAD)
# - Batch processing analyzes HISTORICAL commits (oldest to newest)
# - Running CGR per-batch would create temporal mismatch (old commits vs current code)
# - Solution: Process all batches first, then CGR indexes current state,
#   then correlate historical findings with current codebase to identify:
#   - Entities that still exist → enrich with CGR synthesis
#   - Entities that are historical → mark as superseded/deleted
#
# Version: 1.2

workflow:
  name: batch-analysis
  version: "1.3"
  description: "Unified 14-agent workflow with Tree-KG operators and Code Graph RAG (runs in batches when needed)"
  type: iterative  # Signals coordinator to use batch iteration

  # All 14 agents in the unified workflow:
  # 1. batch_scheduler - Plans chronological batches
  # 2. git_history - Extracts commits with LLM analysis
  # 3. vibe_history - Extracts session logs correlated with commits
  # 4. semantic_analysis - Analyzes semantics with LLM
  # 5. observation_generation - Generates structured observations
  # 6. ontology_classification - Classifies using project ontology
  # 7. kg_operators - Tree-KG operators (conv, aggr, embed, dedup, pred, merge)
  # 8. quality_assurance - Validates quality with retry
  # 9. batch_checkpoint_manager - Saves batch checkpoints
  # 10. code_graph - AST-based code intelligence (via Memgraph)
  # 11. documentation_linker - Links docs/diagrams to code
  # 12. web_search - Searches for similar patterns externally
  # 13. insight_generation - Generates insight documents with diagrams
  # 14. persistence - Persists to LevelDB knowledge graph
  # 15. deduplication - Deduplicates entities
  # 16. content_validation - Validates entity accuracy

config:
  max_concurrent_steps: 2  # Limited concurrency for batch processing
  timeout_per_batch: 300   # 5 minutes per batch
  quality_validation: true
  batch_size: 50           # Commits per batch (overridable via params)
  max_batches: 0           # 0 = process all batches
  checkpoint_enabled: true # Enable per-batch checkpointing

# Parameters that can be passed to the workflow
parameters:
  repositoryPath:
    required: true
    description: "Path to the repository to analyze"
  team:
    required: true
    description: "Team name for knowledge graph storage"
  batchSize:
    default: 50
    description: "Number of commits per batch"
  maxBatches:
    default: 0
    description: "Maximum batches to process (0 = all)"
  resumeFromCheckpoint:
    default: true
    description: "Resume from last completed batch"
  fullAnalysis:
    default: false
    description: "When true, clear checkpoints and analyze all commits from beginning"
  operatorWeights:
    default:
      alpha: 0.6  # Semantic similarity weight
      beta: 0.2   # Adamic-Adar weight
      gamma: 0.2  # Common ancestors weight
    description: "Weights for edge prediction scoring"

# Workflow steps
steps:
  # PHASE 0: Plan Batches (runs once at start)
  - name: plan_batches
    agent: batch_scheduler
    action: planBatches
    parameters:
      repositoryPath: "{{params.repositoryPath}}"
      team: "{{params.team}}"
      batchSize: "{{params.batchSize}}"
      maxBatches: "{{params.maxBatches}}"
      resumeFromCheckpoint: "{{params.resumeFromCheckpoint}}"
      fullAnalysis: "{{params.fullAnalysis}}"
    timeout: 60
    dependencies: []
    phase: initialization

  # NOTE: CGR (Code Graph RAG) steps moved to FINALIZATION phase
  # See architecture note at top of file for rationale

  # --- BATCH LOOP BEGINS (steps with phase: batch are repeated per batch) ---

  # PHASE 1: Extract Batch Data
  - name: extract_batch_commits
    agent: git_history
    action: extractCommitsForBatch
    parameters:
      startCommit: "{{currentBatch.startCommit}}"
      endCommit: "{{currentBatch.endCommit}}"
    timeout: 60
    dependencies:
      - plan_batches
    phase: batch
    operator: extract

  - name: extract_batch_sessions
    agent: vibe_history
    action: extractSessionsForCommits
    parameters:
      commits: "{{extract_batch_commits.result.commits}}"
    timeout: 60
    dependencies:
      - extract_batch_commits
    phase: batch
    operator: extract

  # PHASE 2: Semantic Analysis for Batch (pure historical analysis - no CGR)
  # NOTE: CGR correlation happens in finalization phase after all batches complete
  - name: batch_semantic_analysis
    agent: semantic_analysis
    action: analyzeSemantics
    tier: premium  # Use high-quality model for semantic analysis
    substeps: [sem_data_prep, sem_llm_analysis, sem_observation_gen, sem_entity_transform]
    parameters:
      git_commits: "{{extract_batch_commits.result.commits}}"
      vibe_sessions: "{{extract_batch_sessions.result.sessions}}"
      session_correlations: "{{extract_batch_sessions.result.correlations}}"
      batch_context:
        batchId: "{{currentBatch.id}}"
        startDate: "{{currentBatch.startDate}}"
        endDate: "{{currentBatch.endDate}}"
    timeout: 120
    dependencies:
      - extract_batch_commits
      - extract_batch_sessions
    phase: batch
    operator: analyze

  # PHASE 2.5: Generate Structured Observations
  # Transforms semantic analysis into structured observations for the knowledge graph
  - name: generate_batch_observations
    agent: observation_generation
    action: generateStructuredObservations
    tier: premium
    substeps: [obs_llm_generate, obs_accumulate]
    parameters:
      semantic_analysis: "{{batch_semantic_analysis.result}}"
      git_analysis: "{{extract_batch_commits.result}}"
      vibe_analysis: "{{extract_batch_sessions.result}}"
      batch_context:
        batchId: "{{currentBatch.id}}"
        startDate: "{{currentBatch.startDate}}"
        endDate: "{{currentBatch.endDate}}"
    timeout: 90
    dependencies:
      - batch_semantic_analysis
    phase: batch
    operator: observe

  # PHASE 2.6: Ontology Classification
  - name: classify_with_ontology
    agent: ontology_classification
    action: classifyObservations
    tier: standard
    substeps: [onto_data_prep, onto_llm_classify, onto_apply_results]
    parameters:
      observations: "{{generate_batch_observations.result.observations}}"
      autoExtend: true
      minConfidence: 0.6
    timeout: 120
    dependencies:
      - generate_batch_observations
    phase: batch
    operator: classify

  # PHASE 3: Tree-KG Operators (applied in sequence)
  - name: operator_conv
    agent: kg_operators
    action: contextConvolution
    tier: premium  # Context enrichment needs quality
    parameters:
      entities: "{{classify_with_ontology.result.classified}}"
      batchContext:
        batchId: "{{currentBatch.id}}"
        startDate: "{{currentBatch.startDate}}"
        endDate: "{{currentBatch.endDate}}"
        commits: "{{extract_batch_commits.result.commits}}"
        sessions: "{{extract_batch_sessions.result.sessions}}"
    timeout: 60
    dependencies:
      - classify_with_ontology
    phase: batch
    operator: conv

  - name: operator_aggr
    agent: kg_operators
    action: entityAggregation
    tier: standard
    parameters:
      entities: "{{operator_conv.result}}"
    timeout: 30
    dependencies:
      - operator_conv
    phase: batch
    operator: aggr

  - name: operator_embed
    agent: kg_operators
    action: nodeEmbedding
    tier: fast  # Just embedding API calls
    parameters:
      entities: "{{operator_aggr.result.core}}"
      nonCoreEntities: "{{operator_aggr.result.nonCore}}"
    timeout: 120
    dependencies:
      - operator_aggr
    phase: batch
    operator: embed

  - name: operator_dedup
    agent: kg_operators
    action: deduplication
    tier: standard
    parameters:
      entities: "{{operator_embed.result}}"
      accumulatedKG: "{{accumulatedKG}}"
    timeout: 60
    dependencies:
      - operator_embed
    phase: batch
    operator: dedup

  - name: operator_pred
    agent: kg_operators
    action: edgePrediction
    tier: premium  # Edge prediction needs reasoning
    parameters:
      entities: "{{operator_dedup.result.entities}}"
      accumulatedKG: "{{accumulatedKG}}"
      weights: "{{params.operatorWeights}}"
    timeout: 90
    dependencies:
      - operator_dedup
    phase: batch
    operator: pred

  - name: operator_merge
    agent: kg_operators
    action: structureMerge
    tier: standard
    parameters:
      batchResults:
        entities: "{{operator_dedup.result.entities}}"
        relations: "{{operator_pred.result.edges}}"
      accumulatedKG: "{{accumulatedKG}}"
    timeout: 30
    dependencies:
      - operator_pred
    phase: batch
    operator: merge

  # PHASE 4: Batch Quality Check
  - name: batch_qa
    agent: quality_assurance
    action: validateBatch
    tier: premium  # Accurate QA requires good model
    parameters:
      mergeResult: "{{operator_merge.result}}"
      batchId: "{{currentBatch.id}}"
    timeout: 60
    dependencies:
      - operator_merge
    phase: batch
    operator: qa

  # PHASE 5: Batch Checkpoint
  - name: save_batch_checkpoint
    agent: batch_checkpoint_manager
    action: saveBatchCheckpoint
    parameters:
      batchId: "{{currentBatch.id}}"
      batchNumber: "{{currentBatch.batchNumber}}"
      commitRange:
        start: "{{currentBatch.startCommit}}"
        end: "{{currentBatch.endCommit}}"
      dateRange:
        start: "{{currentBatch.startDate}}"
        end: "{{currentBatch.endDate}}"
      stats: "{{batch_qa.result.stats}}"
    timeout: 10
    dependencies:
      - batch_qa
    phase: batch
    operator: checkpoint

  # --- BATCH LOOP ENDS ---

  # ============================================================================
  # FINALIZATION PHASE: CGR + Correlation + Persistence
  # CGR runs HERE (after all batches) because it indexes CURRENT state,
  # which we then correlate with HISTORICAL batch findings
  # ============================================================================

  # PHASE F1: Code Graph RAG - Index Current Codebase
  # Indexes the current HEAD state of the repository
  - name: index_codebase
    agent: code_graph
    action: indexRepository
    parameters:
      target_path: "{{params.repositoryPath}}"
      forceReindex: "{{params.fullAnalysis}}"
      minNodeThreshold: 1000
    timeout: 600
    dependencies:
      - save_batch_checkpoint  # Wait for ALL batches to complete
    phase: finalization

  # PHASE F2a: Link Documentation
  # Analyze markdown, PlantUML diagrams and link to code entities
  - name: link_documentation
    agent: documentation_linker
    action: analyzeDocumentation
    parameters:
      markdown_paths: ["**/*.md"]
      plantuml_paths: ["**/*.puml", "**/*.plantuml"]
      exclude_patterns: ["**/node_modules/**", "**/dist/**"]
    timeout: 180
    dependencies:
      - save_batch_checkpoint  # Can run parallel to index_codebase
    phase: finalization

  # PHASE F2b: Code Graph RAG - LLM Synthesis
  # Generate insights about current codebase structure
  # NOTE: Now parallelized with 5 concurrent LLM calls, so 30 entities ≈ 6 batches × ~30s = ~3 min
  - name: synthesize_code_insights
    agent: code_graph
    action: synthesizeInsights
    tier: premium
    parameters:
      target_entities: ["Class", "Function"]
      depth: "full"
      limit: 30  # 30 entities in ~6 batches of 5 concurrent calls
    timeout: 300  # 5 minutes (parallelized processing is ~5x faster)
    dependencies:
      - index_codebase
    phase: finalization

  # PHASE F3: Correlate Historical Findings with Current Codebase
  # TODO: This feature is planned but not yet implemented in CodeGraphAgent
  # The correlateHistoricalFindings method needs to be added to enable:
  # - Checking which historical entities still exist in current codebase
  # - Enriching existing entities with CGR synthesis insights
  # - Marking historical-only entities as superseded/deleted
  # For now, this step is skipped and transform_code_entities works without correlation
  #
  # - name: correlate_with_codebase
  #   agent: code_graph
  #   action: correlateHistoricalFindings
  #   tier: premium
  #   parameters:
  #     accumulated_entities: "{{accumulatedKG.entities}}"
  #     codebase_index: "{{index_codebase.result}}"
  #     synthesis_insights: "{{synthesize_code_insights.result}}"
  #     correlation_config:
  #       match_by_name: true
  #       fuzzy_match_threshold: 0.8
  #       mark_historical: true
  #       track_evolution: true
  #   timeout: 180
  #   dependencies:
  #     - synthesize_code_insights
  #   phase: finalization

  # PHASE F4: Transform Code Entities (with documentation results)
  # Note: correlation_results disabled until correlate_with_codebase is implemented
  - name: transform_code_entities
    agent: code_graph
    action: transformToKnowledgeEntities
    parameters:
      codebase_analysis: "{{index_codebase.result}}"
      synthesis_results: "{{synthesize_code_insights.result}}"
      # correlation_results: "{{correlate_with_codebase.result}}"  # Disabled - method not implemented
      documentation_results: "{{link_documentation.result}}"
    timeout: 120
    dependencies:
      - synthesize_code_insights
      - link_documentation
    phase: finalization

  # PHASE F5: Final Persistence (runs once after all batches)
  # NOTE: Now parallelized with 10 concurrent entity writes for ~10x speedup
  - name: final_persist
    agent: persistence
    action: persistEntities
    parameters:
      entities: "{{accumulatedKG.entities}}"
      code_entities: "{{transform_code_entities.result}}"
      # correlated_entities: "{{correlate_with_codebase.result.enriched}}"  # Disabled - correlation not implemented
      # historical_entities: "{{correlate_with_codebase.result.historical}}"  # Disabled - correlation not implemented
      team: "{{params.team}}"
    timeout: 300  # 5 minutes (parallelized processing handles large entity sets)
    dependencies:
      - transform_code_entities
    phase: finalization

  # PHASE F6: Generate Insight Documents
  # Creates detailed markdown documentation for high-value entities
  # This ensures entities have rich documentation like StrategyBasedModularRoutingPattern example
  - name: generate_insights
    agent: insight_generation
    action: generateComprehensiveInsights
    tier: premium
    parameters:
      persisted_entities: "{{final_persist.result}}"
      accumulated_entities: "{{accumulatedKG.entities}}"
      git_analysis_results: "{{accumulatedKG.gitAnalysis}}"
      vibe_analysis_results: "{{accumulatedKG.vibeAnalysis}}"
      code_graph_results: "{{index_codebase.result}}"
      code_synthesis_results: "{{synthesize_code_insights.result}}"
      team: "{{params.team}}"
    timeout: 300
    dependencies:
      - final_persist
      - synthesize_code_insights
    phase: finalization

  # PHASE F7: Web Search for Similar Patterns
  # Searches external resources for similar patterns, best practices, and related work
  - name: web_search
    agent: web_search
    action: searchSimilarPatterns
    tier: standard
    parameters:
      insights: "{{generate_insights.result.insights}}"
      patterns: "{{accumulatedKG.entities}}"
      maxSearches: 10
    timeout: 120
    dependencies:
      - generate_insights
    phase: finalization

  # PHASE F8: Final Deduplication
  - name: final_dedup
    agent: deduplication
    action: deduplicateEntities
    parameters:
      persisted_results: "{{final_persist.result}}"
      insights_results: "{{generate_insights.result}}"
      web_search_results: "{{web_search.result}}"
    timeout: 180
    dependencies:
      - web_search
    phase: finalization

  # PHASE 8: Content Validation
  # NOTE: Now parallelized with 3+ concurrent validation calls per team
  - name: final_validation
    agent: content_validation
    action: validateAllEntities
    parameters:
      deduplicated_results: "{{final_dedup.result}}"
      maxEntitiesPerProject: 50  # 50 entities per project with parallel validation
      skipHealthyEntities: true  # Only report problematic entities
    timeout: 300  # 5 minutes (parallelized processing is ~3x faster)
    dependencies:
      - final_dedup
    phase: finalization

# DAG visualization for batch workflow
# NOTE: CGR runs in FINALIZATION (after all batches), not initialization
# This avoids temporal mismatch between historical commits and current codebase
edges:
  # ========== INITIALIZATION PHASE ==========
  - from: orchestrator
    to: batch_scheduler
    type: control
    label: "plan batches"

  # ========== BATCH LOOP PHASE ==========
  # Batch extraction (parallel: both git and vibe receive batch info)
  - from: batch_scheduler
    to: git_history
    type: dataflow
    label: "per batch"

  - from: batch_scheduler
    to: vibe_history
    type: dataflow
    label: "per batch"

  # Data flow: vibe uses commits from git
  - from: git_history
    to: vibe_history
    type: dataflow
    label: "commits"

  # Semantic analysis (pure historical - NO CGR here)
  - from: git_history
    to: semantic_analysis
    type: dependency
  - from: vibe_history
    to: semantic_analysis
    type: dependency

  # Observation generation (transforms semantics into structured observations)
  - from: semantic_analysis
    to: observation_generation
    type: dataflow
    label: "observe"

  # Ontology classification (classifies observations using project ontology)
  - from: observation_generation
    to: ontology_classification
    type: dataflow
    label: "classify"

  # Semantic analysis also feeds Ontology directly (entities need classification)
  - from: semantic_analysis
    to: ontology_classification
    type: dataflow

  # Tree-KG operator pipeline
  - from: ontology_classification
    to: kg_operators
    type: dependency
    label: "conv"

  - from: kg_operators
    to: kg_operators
    type: self
    label: "conv→aggr→embed→dedup→pred→merge"

  # QA and checkpoint
  - from: kg_operators
    to: quality_assurance
    type: dependency

  # QA RETRY LOOP - Self-loop representing internal retry mechanism
  # When QA fails, coordinator's attemptQARecovery() re-runs FAILED STEPS
  # (could be semantic, insight, observation, etc.) with enhanced parameters:
  # - Progressive tightening: semanticValueThreshold 0.6→0.7→0.8
  # - Stricter requirements: rejectGenericPatterns, requireConcreteEvidence
  # - Up to 3 iterations, then accepts partial results
  - from: quality_assurance
    to: quality_assurance
    type: self
    label: "retry failed steps (3x)"

  - from: quality_assurance
    to: batch_checkpoint_manager
    type: dependency

  # Loop back for next batch
  - from: batch_checkpoint_manager
    to: git_history
    type: control
    label: "next batch"

  # ========== FINALIZATION PHASE ==========
  # CGR and Documentation Linker run in parallel after all batches complete
  - from: batch_checkpoint_manager
    to: code_graph
    type: dependency
    label: "finalize"

  - from: batch_checkpoint_manager
    to: documentation_linker
    type: dependency
    label: "link docs"

  # CGR self-loop for internal phases (index, synthesize, correlate, transform)
  - from: code_graph
    to: code_graph
    type: self
    label: "index→synth→correlate→transform"

  # Code graph also receives accumulated batch entities for correlation
  - from: batch_checkpoint_manager
    to: code_graph
    type: dataflow
    label: "historical entities"

  # Documentation linker feeds into code graph for entity enrichment
  - from: documentation_linker
    to: code_graph
    type: dataflow
    label: "doc links"

  # Code graph outputs to persistence
  - from: code_graph
    to: persistence
    type: dependency
    label: "code + enriched entities"

  # Persistence outputs to insight generation
  - from: persistence
    to: insight_generation
    type: dataflow
    label: "generate docs"

  # Insight generation outputs to web search
  - from: insight_generation
    to: web_search
    type: dataflow
    label: "find patterns"

  # Web search outputs to deduplication
  - from: web_search
    to: deduplication
    type: dataflow

  - from: deduplication
    to: content_validation
    type: dataflow

# Operator tier assignments (for coordinator reference)
operator_tiers:
  conv: premium
  aggr: standard
  embed: fast
  dedup: standard
  pred: premium
  merge: standard
  qa: premium
