import * as fs from 'fs';
import * as path from 'path';
import crypto from 'crypto';
import { log } from '../logging.js';
import { SemanticAnalyzer } from './semantic-analyzer.js';

export interface ObservationTemplate {
  type: 'rule' | 'implementation' | 'validation' | 'workflow' | 'benefits' | 'link' | 'insight' | 'metric' | 'applicability' | 'performance' | 'checklist' | 'critical_rules' | 'tools' | 'compliance' | 'problem' | 'solution' | 'learning' | 'technology' | 'rationale' | 'reference';
  content: string;
  date: string;
  metadata?: Record<string, any>;
}

export interface StructuredObservation {
  name: string; // Matches existing pattern
  entityType: string;
  significance: number; // 1-10, but usually 5, 8, or 9
  observations: (string | ObservationTemplate)[]; // Can be simple strings or structured
  tags?: string[]; // Optional tags for categorization
  relationships: {
    from: string;
    to: string;
    relationType: string;
    type?: string;
    target?: string;
    description?: string;
  }[];
  metadata: {
    created_at: string;
    last_updated: string;
    created_by?: string;
    version?: string;
    team?: string;
    generatedAt?: string;
    sourceData?: any;
    confidence?: number;
    validationStatus?: string;
  };
  id?: string; // Will be generated by persistence layer
}

export interface ObservationGenerationResult {
  observations: StructuredObservation[];
  summary: {
    totalGenerated: number;
    byType: Record<string, number>;
    averageSignificance: number;
    qualityScore: number;
  };
  validationReport: {
    structureCompliance: number;
    contentQuality: number;
    templateAdherence: number;
    issues: string[];
  };
}

export class ObservationGenerationAgent {
  private templates: Map<string, ObservationTemplate[]> = new Map();
  private repositoryPath: string;
  private semanticAnalyzer: SemanticAnalyzer;
  private team: string;

  constructor(repositoryPath: string = '.', team: string = 'coding') {
    this.repositoryPath = repositoryPath;
    this.team = team;
    this.semanticAnalyzer = new SemanticAnalyzer();
    this.initializeTemplates();
  }

  /**
   * Check if an insight document file exists
   * Used to only add "Details:" links when the file actually exists
   */
  private insightFileExists(entityName: string): boolean {
    const insightsDir = path.join(this.repositoryPath, 'knowledge-management', 'insights');
    const filePath = path.join(insightsDir, `${entityName}.md`);
    try {
      return fs.existsSync(filePath);
    } catch {
      return false;
    }
  }

  async generateStructuredObservations(
    gitAnalysis: any,
    vibeAnalysis: any,
    semanticAnalysis: any,
    webSearchResults?: any
  ): Promise<ObservationGenerationResult> {
    // Handle both direct parameters and coordinator parameter object
    let actualGitAnalysis = gitAnalysis;
    let actualVibeAnalysis = vibeAnalysis;
    let actualSemanticAnalysis = semanticAnalysis;
    let actualWebSearchResults = webSearchResults;
    let insightsResults: any = null;
    
    // Check if called with single parameter object from coordinator
    if (arguments.length === 1 && typeof gitAnalysis === 'object' && 
        (gitAnalysis.git_analysis_results || gitAnalysis.insights_results)) {
      const params = gitAnalysis;
      actualGitAnalysis = params.git_analysis_results || params.gitAnalysis;
      actualVibeAnalysis = params.vibe_analysis_results || params.vibeAnalysis;
      actualSemanticAnalysis = params.semantic_analysis_results || params.semanticAnalysis;
      actualWebSearchResults = params.web_search_results || params.webSearchResults;
      insightsResults = params.insights_results || params.insights;
      
      log('Detected coordinator parameter format', 'info', {
        hasGitAnalysis: !!actualGitAnalysis,
        hasVibeAnalysis: !!actualVibeAnalysis,
        hasSemanticAnalysis: !!actualSemanticAnalysis,
        hasInsightsResults: !!insightsResults
      });
    }
    
    log('Starting structured observation generation', 'info', {
      gitCommits: actualGitAnalysis?.commits?.length || 0,
      vibeSessions: actualVibeAnalysis?.sessions?.length || 0,
      hasSemanticAnalysis: !!actualSemanticAnalysis,
      hasInsightsResults: !!insightsResults
    });

    try {
      const observations: StructuredObservation[] = [];

      // Generate observations from git analysis
      if (actualGitAnalysis) {
        const gitObservations = await this.generateFromGitAnalysis(actualGitAnalysis);
        observations.push(...gitObservations);
      }

      // Generate observations from vibe analysis
      if (actualVibeAnalysis) {
        const vibeObservations = await this.generateFromVibeAnalysis(actualVibeAnalysis);
        observations.push(...vibeObservations);
      }

      // Generate observations from semantic analysis
      if (actualSemanticAnalysis) {
        const semanticObservations = await this.generateFromSemanticAnalysis(actualSemanticAnalysis);
        observations.push(...semanticObservations);
      }
      
      // Generate observations from insights results
      if (insightsResults) {
        const insightObservations = await this.generateFromInsightsResults(insightsResults);
        observations.push(...insightObservations);
        log(`Generated ${insightObservations.length} observations from insights`, 'info');
      }

      // Generate cross-analysis observations
      const crossObservations = await this.generateCrossAnalysisObservations(
        actualGitAnalysis, actualVibeAnalysis, actualSemanticAnalysis
      );
      observations.push(...crossObservations);

      // Enhance with web search results
      if (actualWebSearchResults) {
        await this.enhanceWithWebSearch(observations, actualWebSearchResults);
      }

      // Validate observations
      const validationReport = this.validateObservations(observations);

      // Generate summary
      const summary = this.generateSummary(observations);

      log('Structured observation generation completed', 'info', {
        totalObservations: observations.length,
        averageSignificance: summary.averageSignificance,
        qualityScore: validationReport.contentQuality
      });

      return {
        observations,
        summary,
        validationReport
      };

    } catch (error) {
      log('Observation generation failed', 'error', error);
      throw error;
    }
  }

  private initializeTemplates(): void {
    // Based on existing patterns in knowledge-export/coding.json
    
    // Rule template - critical guidelines
    this.templates.set('rule', [
      {
        type: 'rule',
        content: 'Always follow established pattern for consistent implementation',
        date: new Date().toISOString(),
        metadata: { category: 'guideline', enforcement: 'strict' }
      }
    ]);

    // Implementation template - how it's done
    this.templates.set('implementation', [
      {
        type: 'implementation',
        content: 'Specific technical approach and methods used',
        date: new Date().toISOString(),
        metadata: { technical: true, reusable: true }
      }
    ]);

    // Insight template - key learnings
    this.templates.set('insight', [
      {
        type: 'insight',
        content: 'Important understanding or realization from the experience',
        date: new Date().toISOString(),
        metadata: { transferable: true, impact: 'high' }
      }
    ]);

    // Applicability template - where it applies
    this.templates.set('applicability', [
      {
        type: 'applicability',
        content: 'Contexts and scenarios where this pattern applies',
        date: new Date().toISOString(),
        metadata: { scope: 'broad', generalizability: 'high' }
      }
    ]);

    // Link template - references to detailed docs
    this.templates.set('link', [
      {
        type: 'link',
        content: 'Details: http://localhost:8080/knowledge-management/insights/PatternName.md',
        date: new Date().toISOString(),
        metadata: { source: 'documentation', type: 'reference' }
      }
    ]);

    // Metric template - measurable outcomes
    this.templates.set('metric', [
      {
        type: 'metric',
        content: 'Quantifiable results and performance indicators',
        date: new Date().toISOString(),
        metadata: { measurable: true, trackable: true }
      }
    ]);
  }

  private async generateFromGitAnalysis(gitAnalysis: any): Promise<StructuredObservation[]> {
    const observations: StructuredObservation[] = [];

    // Generate observations for architectural decisions
    if (gitAnalysis.architecturalDecisions) {
      for (const decision of gitAnalysis.architecturalDecisions) {
        const observation = await this.createArchitecturalDecisionObservation(decision, gitAnalysis);
        if (observation) observations.push(observation);
      }
    }

    // Generate observations for code evolution patterns
    if (gitAnalysis.codeEvolution) {
      for (const pattern of gitAnalysis.codeEvolution.slice(0, 5)) { // Top 5 patterns
        const observation = await this.createCodeEvolutionObservation(pattern, gitAnalysis);
        if (observation) observations.push(observation);
      }
    }

    return observations;
  }

  private async createArchitecturalDecisionObservation(
    decision: any, 
    gitAnalysis: any
  ): Promise<StructuredObservation | null> {
    try {
      const entityName = this.generateEntityName(decision.type, decision.description);
      const currentDate = new Date().toISOString();

      // Create concise observations that match existing pattern
      const observations: (string | ObservationTemplate)[] = [
        `${decision.type} architectural decision involving ${decision.files.length} files with ${decision.impact} impact`,
        {
          type: 'implementation',
          content: `${decision.description} (commit: ${decision.commit})`,
          date: currentDate
        },
        {
          type: 'insight',
          content: `${decision.type} changes require careful coordination across ${decision.files.length} files`,
          date: currentDate
        },
        {
          type: 'applicability',
          content: `Similar ${decision.type} decisions in ${this.extractTechnologiesFromFiles(decision.files).join(', ')} projects`,
          date: currentDate
        },
        {
          type: 'metric',
          content: `Files: ${decision.files.length}, Impact: ${decision.impact}, Commit: ${decision.commit}`,
          date: currentDate
        }
      ];

      // Only add Details link if the insight file actually exists
      if (this.insightFileExists(entityName)) {
        observations.push({
          type: 'link',
          content: `Details: http://localhost:8080/knowledge-management/insights/${entityName}.md`,
          date: currentDate
        });
      }

      return {
        name: entityName,
        entityType: 'TransferablePattern',
        significance: this.calculateSignificance(decision.impact, decision.files.length),
        observations,
        relationships: [
          {
            from: entityName,
            to: 'CollectiveKnowledge',
            relationType: 'contributes to'
          },
          {
            from: entityName,
            to: 'Coding',
            relationType: 'implemented in'
          }
        ],
        metadata: {
          created_at: currentDate,
          last_updated: currentDate,
          created_by: 'semantic-analysis-agent',
          version: '1.0',
          team: this.team
        }
      };

    } catch (error) {
      log('Failed to create architectural decision observation', 'error', error);
      return null;
    }
  }

  private async createCodeEvolutionObservation(
    pattern: any,
    gitAnalysis: any
  ): Promise<StructuredObservation | null> {
    try {
      const entityName = this.generateEntityName('CodeEvolution', pattern.pattern);
      const currentDate = new Date().toISOString();

      const observations: ObservationTemplate[] = [
        {
          type: 'problem',
          content: `Recurring development pattern identified: ${pattern.pattern}`,
          date: currentDate,
          metadata: {
            frequency: pattern.occurrences,
            trend: pattern.trend
          }
        },
        {
          type: 'solution',
          content: `Consistent approach applied ${pattern.occurrences} times across ${pattern.files.length} files`,
          date: currentDate,
          metadata: {
            approach: pattern.pattern,
            consistency: pattern.occurrences > 3 ? 'high' : 'medium'
          }
        },
        {
          type: 'learning',
          content: `Pattern shows ${pattern.trend} trend, indicating ${this.interpretTrend(pattern.trend, pattern.pattern)}`,
          date: currentDate,
          metadata: {
            transferable: true,
            domain: 'development-process'
          }
        },
        {
          type: 'applicability',
          content: `Applies to similar ${pattern.pattern} scenarios in TypeScript/JavaScript projects`,
          date: currentDate,
          metadata: {
            scope: 'project-type',
            generalizability: 'high'
          }
        },
        {
          type: 'metric',
          content: `Occurrences: ${pattern.occurrences}, Files: ${pattern.files.length}, Trend: ${pattern.trend}`,
          date: currentDate,
          metadata: {
            quantifiable: true,
            baseline: pattern.occurrences,
            trend: pattern.trend
          }
        }
      ];

      return {
        name: entityName,
        entityType: 'CodeEvolutionPattern',
        significance: Math.min(Math.ceil(pattern.occurrences / 2), 10),
        observations,
        tags: [pattern.pattern.replace(/\s+/g, ''), pattern.trend, 'evolution', 'git-analysis'],
        relationships: [
          {
            from: entityName,
            to: 'GitHistoryAnalysis',
            relationType: 'evidencedBy',
            type: 'evidencedBy',
            target: 'GitHistoryAnalysis',
            description: `Pattern observed across ${pattern.commits.length} commits`
          }
        ],
        metadata: {
          created_at: currentDate,
          last_updated: currentDate,
          generatedAt: currentDate,
          sourceData: ['git-history'],
          confidence: 0.8,
          validationStatus: 'pending'
        }
      };

    } catch (error) {
      log('Failed to create code evolution observation', 'error', error);
      return null;
    }
  }

  private async generateFromVibeAnalysis(vibeAnalysis: any): Promise<StructuredObservation[]> {
    const observations: StructuredObservation[] = [];

    // Generate observations for problem-solution pairs
    if (vibeAnalysis.problemSolutionPairs) {
      for (const pair of vibeAnalysis.problemSolutionPairs.slice(0, 10)) { // Top 10 pairs
        const observation = await this.createProblemSolutionObservation(pair, vibeAnalysis);
        if (observation) observations.push(observation);
      }
    }

    // Generate observations for development contexts
    if (vibeAnalysis.developmentContexts) {
      const contextGroups = this.groupContextsByType(vibeAnalysis.developmentContexts);
      for (const [type, contexts] of contextGroups.entries()) {
        const observation = await this.createContextGroupObservation(type, contexts, vibeAnalysis);
        if (observation) observations.push(observation);
      }
    }

    return observations;
  }

  private async createProblemSolutionObservation(
    pair: any,
    vibeAnalysis: any
  ): Promise<StructuredObservation | null> {
    try {
      const entityName = this.generateEntityName('ProblemSolution', pair.problem.description);
      const currentDate = new Date().toISOString();

      // Create observations matching existing style - mix of strings and structured objects
      const observations: (string | ObservationTemplate)[] = [
        pair.problem.description.length > 100 ? pair.problem.description.substring(0, 100) + '...' : pair.problem.description,
        {
          type: 'implementation',
          content: `${pair.solution.approach} using ${pair.solution.technologies.join(', ')}`,
          date: currentDate
        },
        {
          type: 'insight',
          content: `${pair.problem.difficulty} difficulty problems benefit from ${pair.solution.steps.length > 2 ? 'systematic' : 'direct'} approach`,
          date: currentDate
        },
        {
          type: 'applicability',
          content: `Similar ${pair.problem.difficulty} difficulty development challenges in conversation-driven environments`,
          date: currentDate
        },
        {
          type: 'metric',
          content: `Solution steps: ${pair.solution.steps.length}, Technologies: ${pair.solution.technologies.length}, Outcome: ${pair.solution.outcome}`,
          date: currentDate
        }
      ];

      // Only add Details link if the insight file actually exists
      if (this.insightFileExists(entityName)) {
        observations.push({
          type: 'link',
          content: `Details: http://localhost:8080/knowledge-management/insights/${entityName}.md`,
          date: currentDate
        });
      }

      return {
        name: entityName,
        entityType: 'TransferablePattern',
        significance: this.calculateSignificanceFromDifficulty(pair.problem.difficulty),
        observations,
        relationships: [
          {
            from: entityName,
            to: 'CollectiveKnowledge',
            relationType: 'contributes to'
          },
          {
            from: entityName,
            to: 'Coding',
            relationType: 'implemented in'
          }
        ],
        metadata: {
          created_at: currentDate,
          last_updated: currentDate,
          created_by: 'semantic-analysis-agent',
          version: '1.0',
          team: this.team
        }
      };

    } catch (error) {
      log('Failed to create problem-solution observation', 'error', error);
      return null;
    }
  }

  private groupContextsByType(contexts: any[]): Map<string, any[]> {
    const groups = new Map<string, any[]>();
    
    contexts.forEach(context => {
      const type = context.problemType || 'General';
      if (!groups.has(type)) {
        groups.set(type, []);
      }
      groups.get(type)!.push(context);
    });

    return groups;
  }

  private async createContextGroupObservation(
    type: string,
    contexts: any[],
    vibeAnalysis: any
  ): Promise<StructuredObservation | null> {
    try {
      const entityName = this.generateEntityName('DevelopmentContext', type);
      const currentDate = new Date().toISOString();

      const totalContexts = contexts.length;
      const commonTechnologies = this.extractCommonTechnologies(contexts);
      const successfulOutcomes = contexts.filter(c => c.outcomes.length > 0).length;

      const observations: ObservationTemplate[] = [
        {
          type: 'problem',
          content: `Recurring development context: ${type} activities across ${totalContexts} conversation sessions`,
          date: currentDate,
          metadata: {
            frequency: totalContexts,
            type: type
          }
        },
        {
          type: 'solution',
          content: `Consistent approach patterns identified for ${type} problems`,
          date: currentDate,
          metadata: {
            approach: type,
            successRate: Math.round((successfulOutcomes / totalContexts) * 100)
          }
        },
        {
          type: 'learning',
          content: `${type} contexts show ${successfulOutcomes}/${totalContexts} success rate with common use of ${commonTechnologies.slice(0, 3).join(', ')}`,
          date: currentDate,
          metadata: {
            transferable: true,
            domain: 'development-workflow'
          }
        },
        {
          type: 'technology',
          content: commonTechnologies.join(', '),
          date: currentDate,
          metadata: {
            tools: commonTechnologies,
            contexts: totalContexts
          }
        },
        {
          type: 'metric',
          content: `Contexts: ${totalContexts}, Success rate: ${Math.round((successfulOutcomes / totalContexts) * 100)}%`,
          date: currentDate,
          metadata: {
            quantifiable: true,
            baseline: totalContexts,
            successRate: successfulOutcomes / totalContexts
          }
        }
      ];

      return {
        name: entityName,
        entityType: 'DevelopmentContextPattern',
        significance: Math.min(Math.ceil(totalContexts / 2), 8),
        observations,
        tags: [type.replace(/\s+/g, ''), 'context', 'workflow', 'vibe-analysis'],
        relationships: [
          {
            from: entityName,
            to: 'VibeHistoryAnalysis',
            relationType: 'aggregatedFrom',
            type: 'aggregatedFrom',
            target: 'VibeHistoryAnalysis',
            description: `Aggregated from ${totalContexts} development contexts`
          }
        ],
        metadata: {
          created_at: currentDate,
          last_updated: currentDate,
          generatedAt: currentDate,
          sourceData: ['vibe-history'],
          confidence: 0.85,
          validationStatus: 'pending'
        }
      };

    } catch (error) {
      log('Failed to create context group observation', 'error', error);
      return null;
    }
  }

  private async generateFromSemanticAnalysis(semanticAnalysis: any): Promise<StructuredObservation[]> {
    const observations: StructuredObservation[] = [];

    // Generate observations for key insights
    if (semanticAnalysis.insights) {
      const insights = Array.isArray(semanticAnalysis.insights) 
        ? semanticAnalysis.insights 
        : [semanticAnalysis.insights];

      for (const insight of insights.slice(0, 5)) {
        const observation = await this.createSemanticInsightObservation(insight, semanticAnalysis);
        if (observation) observations.push(observation);
      }
    }

    return observations;
  }

  private async generateFromInsightsResults(insightsResults: any): Promise<StructuredObservation[]> {
    const observations: StructuredObservation[] = [];
    
    log('Processing insights results', 'info', {
      hasInsightDocument: !!insightsResults?.insightDocument,
      hasInsightDocuments: !!insightsResults?.insightDocuments,
      insightDocumentsCount: insightsResults?.insightDocuments?.length || 0,
      hasPatternCatalog: !!insightsResults?.patternCatalog
    });
    
    // Process multiple insight documents if available
    if (insightsResults?.insightDocuments && Array.isArray(insightsResults.insightDocuments)) {
      for (const insightDoc of insightsResults.insightDocuments) {
        const observation = await this.createInsightDocumentObservation(insightDoc);
        if (observation) {
          observations.push(observation);
          log(`Created observation for insight: ${insightDoc.name}`, 'info');
        }
      }
    } 
    // Process single insight document if available
    else if (insightsResults?.insightDocument) {
      const observation = await this.createInsightDocumentObservation(insightsResults.insightDocument);
      if (observation) {
        observations.push(observation);
      }
    }
    
    // Process pattern catalog if available
    if (insightsResults?.patternCatalog?.patterns) {
      for (const pattern of insightsResults.patternCatalog.patterns) {
        const observation = await this.createPatternObservation(pattern);
        if (observation) {
          observations.push(observation);
        }
      }
    }
    
    return observations;
  }
  
  private async createInsightDocumentObservation(insightDoc: any): Promise<StructuredObservation | null> {
    try {
      const currentDate = new Date().toISOString();
      const cleanName = insightDoc.name || 'UnknownInsight';

      const observations: ObservationTemplate[] = [
        {
          type: 'insight',
          content: `${cleanName} - ${insightDoc.title || 'Comprehensive Pattern Analysis'}`,
          date: currentDate,
          metadata: {
            transferable: true,
            domain: 'pattern-analysis',
            significance: insightDoc.metadata?.significance || 8
          }
        },
        {
          type: 'solution',
          content: insightDoc.content?.substring(0, 500) || 'Pattern implementation and analysis',
          date: currentDate,
          metadata: {
            technical: true,
            patterns: insightDoc.metadata?.tags || []
          }
        }
      ];

      // Only add Details link if the insight file actually exists
      if (this.insightFileExists(cleanName)) {
        observations.push({
          type: 'link',
          content: `Details: http://localhost:8080/knowledge-management/insights/${cleanName}.md`,
          date: currentDate,
          metadata: {
            source: 'insight-generation',
            fileValidated: true
          }
        });
      }
      
      // Add metrics if available
      if (insightDoc.metadata?.patternCount) {
        observations.push({
          type: 'metric',
          content: `Pattern analysis identified ${insightDoc.metadata.patternCount} distinct patterns`,
          date: currentDate,
          metadata: {
            count: insightDoc.metadata.patternCount,
            analysisTypes: insightDoc.metadata.analysisTypes || []
          }
        });
      }
      
      return {
        name: cleanName,
        entityType: 'TransferablePattern',
        significance: insightDoc.metadata?.significance || 8,
        observations,
        tags: insightDoc.metadata?.tags || ['pattern', 'insight', 'analysis'],
        relationships: [],
        metadata: {
          created_at: currentDate,
          last_updated: currentDate,
          created_by: 'insight-generation-agent',
          version: '1.0',
          team: this.team,
          generatedAt: insightDoc.metadata?.generatedAt || currentDate,
          sourceData: {
            analysisTypes: insightDoc.metadata?.analysisTypes || [],
            patternCount: insightDoc.metadata?.patternCount || 0
          }
        }
      };
    } catch (error) {
      log('Failed to create insight document observation', 'error', error);
      return null;
    }
  }
  
  private async createPatternObservation(pattern: any): Promise<StructuredObservation | null> {
    try {
      const currentDate = new Date().toISOString();
      const patternName = pattern.name || 'UnknownPattern';
      
      const observations: ObservationTemplate[] = [
        {
          type: 'insight',
          content: pattern.description || 'Pattern identified through analysis',
          date: currentDate,
          metadata: {
            category: pattern.category,
            significance: pattern.significance
          }
        }
      ];
      
      // Add implementation details if available
      if (pattern.implementation) {
        observations.push({
          type: 'implementation',
          content: pattern.implementation.codeExample || pattern.implementation.usageNotes?.join('; ') || 'Implementation details',
          date: currentDate,
          metadata: {
            language: pattern.implementation.language,
            reusable: true
          }
        });
      }
      
      // Add evidence if available
      if (pattern.evidence && pattern.evidence.length > 0) {
        observations.push({
          type: 'validation',
          content: `Evidence: ${pattern.evidence.slice(0, 3).join('; ')}`,
          date: currentDate,
          metadata: {
            evidenceCount: pattern.evidence.length
          }
        });
      }
      
      return {
        name: patternName,
        entityType: pattern.category || 'Pattern',
        significance: pattern.significance || 5,
        observations,
        tags: [pattern.category, 'pattern', ...pattern.relatedComponents || []],
        relationships: pattern.relatedComponents?.map((comp: string) => ({
          from: patternName,
          to: comp,
          relationType: 'relatesTo',
          type: 'relatesTo',
          target: comp
        })) || [],
        metadata: {
          created_at: currentDate,
          last_updated: currentDate,
          created_by: 'pattern-analysis',
          version: '1.0',
          team: this.team
        }
      };
    } catch (error) {
      log('Failed to create pattern observation', 'error', error);
      return null;
    }
  }

  private async createSemanticInsightObservation(
    insight: any,
    semanticAnalysis: any
  ): Promise<StructuredObservation | null> {
    try {
      const insightText = typeof insight === 'string' ? insight : insight.description || 'Semantic insight';
      const entityName = this.generateEntityName('SemanticInsight', insightText);
      const currentDate = new Date().toISOString();

      // ENHANCEMENT: Use LLM to extract deeper insights and categorization
      let enhancedInsights: any = null;
      try {
        const prompt = `Analyze this technical insight and extract structured information:

Insight: ${insightText}

Provide a JSON response with:
{
  "keyLearnings": string[], // 2-3 specific actionable learnings
  "technicalDomain": string, // e.g., "architecture", "performance", "security"
  "applicabilityScope": string, // Who can benefit from this
  "confidence": number, // 0-1
  "actionableRecommendations": string[] // 2-3 specific recommendations
}`;

        const result = await this.semanticAnalyzer.analyzeContent(prompt, {
          analysisType: "general",
          provider: "auto",
          taskType: "observation_generation"  // Uses premium tier for quality observations
        });

        enhancedInsights = JSON.parse(result.insights);
        log("LLM-enhanced insight extraction completed", "info", {
          domain: enhancedInsights.technicalDomain,
          confidence: enhancedInsights.confidence
        });
      } catch (error) {
        log("LLM insight enhancement failed, using template-based approach", "warning", error);
      }

      const observations: ObservationTemplate[] = [
        {
          type: 'learning',
          content: enhancedInsights?.keyLearnings?.join('. ') || insightText,
          date: currentDate,
          metadata: {
            transferable: true,
            domain: enhancedInsights?.technicalDomain || 'semantic-analysis',
            confidence: enhancedInsights?.confidence || 0.7
          }
        },
        {
          type: 'rationale',
          content: 'Insight derived from semantic analysis of git and conversation history',
          date: currentDate,
          metadata: {
            factors: ['semantic-analysis', 'pattern-recognition', 'cross-source'],
            tradeoffs: ['comprehensive analysis', 'high confidence']
          }
        },
        {
          type: 'applicability',
          content: enhancedInsights?.applicabilityScope || 'Applies to similar software development projects with rich commit and conversation history',
          date: currentDate,
          metadata: {
            scope: enhancedInsights?.technicalDomain || 'software-development',
            generalizability: 'high'
          }
        }
      ];

      // Add actionable recommendations if available
      if (enhancedInsights?.actionableRecommendations) {
        enhancedInsights.actionableRecommendations.forEach((recommendation: string) => {
          observations.push({
            type: 'implementation',
            content: recommendation,
            date: currentDate,
            metadata: {
              priority: 'medium',
              actionable: true
            }
          });
        });
      }

      return {
        name: entityName,
        entityType: 'SemanticInsight',
        significance: 7, // Default high significance for semantic insights
        observations,
        tags: ['semantic', 'insight', 'analysis', 'cross-source'],
        relationships: [
          {
            from: entityName,
            to: 'SemanticAnalysis',
            relationType: 'derivedFrom',
            type: 'derivedFrom',
            target: 'SemanticAnalysis',
            description: 'Generated through semantic analysis of multiple data sources'
          }
        ],
        metadata: {
          created_at: currentDate,
          last_updated: currentDate,
          generatedAt: currentDate,
          sourceData: ['semantic-analysis'],
          confidence: 0.88,
          validationStatus: 'pending'
        }
      };

    } catch (error) {
      log('Failed to create semantic insight observation', 'error', error);
      return null;
    }
  }

  private async generateCrossAnalysisObservations(
    gitAnalysis: any,
    vibeAnalysis: any,
    semanticAnalysis: any
  ): Promise<StructuredObservation[]> {
    const observations: StructuredObservation[] = [];

    // Correlate git patterns with conversation patterns
    if (gitAnalysis?.codeEvolution && vibeAnalysis?.patterns?.developmentThemes) {
      const correlation = this.correlatePatternsAcrossSources(
        gitAnalysis.codeEvolution,
        vibeAnalysis.patterns.developmentThemes
      );

      if (correlation) {
        observations.push(correlation);
      }
    }

    return observations;
  }

  private correlatePatternsAcrossSources(
    gitPatterns: any[],
    vibeThemes: any[]
  ): StructuredObservation | null {
    try {
      const entityName = this.generateEntityName('CrossAnalysis', 'GitVibeCorrelation');
      const currentDate = new Date().toISOString();

      const topGitPattern = gitPatterns[0]?.pattern || 'No pattern';
      const topVibeTheme = vibeThemes[0]?.theme || 'No theme';

      const observations: ObservationTemplate[] = [
        {
          type: 'learning',
          content: `Correlation identified between git activity (${topGitPattern}) and conversation focus (${topVibeTheme})`,
          date: currentDate,
          metadata: {
            transferable: true,
            domain: 'cross-analysis'
          }
        },
        {
          type: 'rationale',
          content: 'Cross-source analysis reveals alignment between code changes and development discussions',
          date: currentDate,
          metadata: {
            factors: ['git-analysis', 'conversation-analysis', 'pattern-correlation'],
            tradeoffs: ['comprehensive view', 'complex analysis']
          }
        },
        {
          type: 'applicability',
          content: 'Pattern applicable to projects with active development and documentation through conversations',
          date: currentDate,
          metadata: {
            scope: 'active-development',
            generalizability: 'medium'
          }
        }
      ];

      return {
        name: entityName,
        entityType: 'CrossAnalysisPattern',
        significance: 8,
        observations,
        tags: ['cross-analysis', 'correlation', 'git-vibe', 'pattern'],
        relationships: [
          {
            from: entityName,
            to: 'GitHistoryAnalysis',
            relationType: 'correlates',
            type: 'correlates',
            target: 'GitHistoryAnalysis',
            description: 'Correlates git patterns with conversation themes'
          },
          {
            from: entityName,
            to: 'VibeHistoryAnalysis',
            relationType: 'correlates',
            type: 'correlates',
            target: 'VibeHistoryAnalysis',
            description: 'Correlates conversation themes with git patterns'
          }
        ],
        metadata: {
          created_at: currentDate,
          last_updated: currentDate,
          generatedAt: currentDate,
          sourceData: ['git-history', 'vibe-history'],
          confidence: 0.75,
          validationStatus: 'pending'
        }
      };

    } catch (error) {
      log('Failed to create cross-analysis observation', 'error', error);
      return null;
    }
  }

  private async enhanceWithWebSearch(
    observations: StructuredObservation[],
    webSearchResults: any
  ): Promise<void> {
    // Add reference observations from web search results
    observations.forEach(observation => {
      if (webSearchResults?.references) {
        observation.observations.push({
          type: 'reference',
          content: `External resources: ${webSearchResults.references.slice(0, 3).join(', ')}`,
          date: new Date().toISOString(),
          metadata: {
            source: 'web-search',
            reliability: 'medium'
          }
        });
      }
    });
  }

  public validateObservations(observations: StructuredObservation[]): ObservationGenerationResult['validationReport'] {
    let structureCompliance = 0;
    let contentQuality = 0;
    let templateAdherence = 0;
    const issues: string[] = [];

    for (const observation of observations) {
      // Structure compliance
      const hasRequiredFields = !!(observation.name && observation.entityType && observation.observations);
      const hasValidSignificance = observation.significance >= 1 && observation.significance <= 10;
      const hasObservations = observation.observations.length > 0;
      
      if (hasRequiredFields && hasValidSignificance && hasObservations) {
        structureCompliance++;
      } else {
        issues.push(`${observation.name}: Structure compliance issues`);
      }

      // Content quality
      const hasSubstantialContent = observation.observations.some(obs => {
        if (typeof obs === 'string') return obs.length > 50;
        return obs.content.length > 50;
      });
      const hasVariedObservations = new Set(observation.observations.map(obs => {
        if (typeof obs === 'string') return 'simple';
        return obs.type;
      })).size > 1;
      
      if (hasSubstantialContent && hasVariedObservations) {
        contentQuality++;
      } else {
        issues.push(`${observation.name}: Content quality issues`);
      }

      // Template adherence
      const hasValidTypes = observation.observations.every(obs => {
        if (typeof obs === 'string') return true; // Simple strings are valid
        return ['problem', 'solution', 'rationale', 'learning', 'applicability', 'technology', 'reference', 'metric'].includes(obs.type);
      });
      const hasMetadata = observation.observations.every(obs => {
        if (typeof obs === 'string') return true; // Simple strings don't need metadata
        return obs.metadata;
      });
      
      if (hasValidTypes && hasMetadata) {
        templateAdherence++;
      } else {
        issues.push(`${observation.name}: Template adherence issues`);
      }
    }

    const total = observations.length || 1;
    return {
      structureCompliance: Math.round((structureCompliance / total) * 100),
      contentQuality: Math.round((contentQuality / total) * 100),
      templateAdherence: Math.round((templateAdherence / total) * 100),
      issues
    };
  }

  private generateSummary(observations: StructuredObservation[]): ObservationGenerationResult['summary'] {
    const byType: Record<string, number> = {};
    let totalSignificance = 0;

    observations.forEach(observation => {
      byType[observation.entityType] = (byType[observation.entityType] || 0) + 1;
      totalSignificance += observation.significance;
    });

    const averageSignificance = observations.length > 0 ? Math.round(totalSignificance / observations.length) : 0;
    
    // Calculate quality score based on various factors
    const avgObservationsPerEntity = observations.length > 0 
      ? observations.reduce((sum, obs) => sum + obs.observations.length, 0) / observations.length 
      : 0;
    const avgRelationships = observations.length > 0
      ? observations.reduce((sum, obs) => sum + obs.relationships.length, 0) / observations.length
      : 0;

    const qualityScore = Math.min(
      Math.round((averageSignificance / 10) * 40 + (avgObservationsPerEntity / 5) * 30 + (avgRelationships / 2) * 30),
      100
    );

    return {
      totalGenerated: observations.length,
      byType,
      averageSignificance,
      qualityScore
    };
  }

  // Helper methods
  private generateEntityName(type: string, description: string): string {
    // Create a clean, CamelCase entity name that matches existing patterns
    const cleaned = description
      .replace(/[^a-zA-Z0-9\s]/g, '')
      .trim()
      .split(/\s+/)
      .slice(0, 3) // Max 3 words to keep it concise
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join('');

    // Combine type and cleaned description
    const typeCapitalized = type.charAt(0).toUpperCase() + type.slice(1).toLowerCase();
    return `${typeCapitalized}${cleaned}Pattern`;
  }

  private calculateSignificance(impact: string, fileCount: number): number {
    // Match existing significance patterns: mostly 5, sometimes 8-9 for critical
    switch (impact) {
      case 'high': 
        return fileCount > 15 ? 9 : 8; // 9 for very large changes, 8 for high impact
      case 'medium': 
        return 5; // Standard significance
      case 'low': 
        return 5; // Still valuable for knowledge base
      default: 
        return 5;
    }
  }

  private calculateSignificanceFromDifficulty(difficulty: string): number {
    // Match existing significance patterns
    switch (difficulty) {
      case 'high': return 8;
      case 'medium': return 5;
      case 'low': return 5; // Still valuable
      default: return 5;
    }
  }

  private extractTechnologiesFromFiles(files: string[]): string[] {
    const technologies = new Set<string>();
    
    files.forEach(file => {
      const ext = path.extname(file).toLowerCase();
      switch (ext) {
        case '.ts': technologies.add('TypeScript'); break;
        case '.js': technologies.add('JavaScript'); break;
        case '.json': technologies.add('JSON'); break;
        case '.md': technologies.add('Markdown'); break;
        case '.py': technologies.add('Python'); break;
        case '.yml':
        case '.yaml': technologies.add('YAML'); break;
      }
    });
    
    return Array.from(technologies);
  }

  private extractCommonTechnologies(contexts: any[]): string[] {
    const techCounts = new Map<string, number>();
    
    contexts.forEach(context => {
      if (context.technicalDetails) {
        context.technicalDetails.forEach((detail: string) => {
          if (detail.startsWith('Tool: ')) {
            const tool = detail.replace('Tool: ', '');
            techCounts.set(tool, (techCounts.get(tool) || 0) + 1);
          }
        });
      }
    });
    
    return Array.from(techCounts.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, 5)
      .map(([tech]) => tech);
  }

  private interpretTrend(trend: string, pattern: string): string {
    switch (trend) {
      case 'increasing':
        return `growing emphasis on ${pattern}`;
      case 'decreasing':
        return `reduced focus on ${pattern}`;
      case 'stable':
        return `consistent approach to ${pattern}`;
      default:
        return `ongoing ${pattern} activity`;
    }
  }
}