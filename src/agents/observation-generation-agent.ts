import * as fs from 'fs';
import * as path from 'path';
import crypto from 'crypto';
import { log } from '../logging.js';
import { SemanticAnalyzer } from './semantic-analyzer.js';

export interface ObservationTemplate {
  type: 'rule' | 'implementation' | 'validation' | 'workflow' | 'benefits' | 'link' | 'insight' | 'metric' | 'applicability' | 'performance' | 'checklist' | 'critical_rules' | 'tools' | 'compliance' | 'problem' | 'solution' | 'learning' | 'technology' | 'rationale' | 'reference';
  content: string;
  date: string;
  metadata?: Record<string, any>;
}

export interface StructuredObservation {
  name: string; // Matches existing pattern
  entityType: string;
  significance: number; // 1-10, but usually 5, 8, or 9
  observations: (string | ObservationTemplate)[]; // Can be simple strings or structured
  tags?: string[]; // Optional tags for categorization
  relationships: {
    from: string;
    to: string;
    relationType: string;
    type?: string;
    target?: string;
    description?: string;
  }[];
  metadata: {
    created_at: string;
    last_updated: string;
    created_by?: string;
    version?: string;
    team?: string;
    generatedAt?: string;
    sourceData?: any;
    confidence?: number;
    validationStatus?: string;
  };
  id?: string; // Will be generated by persistence layer
}

export interface ObservationGenerationResult {
  observations: StructuredObservation[];
  summary: {
    totalGenerated: number;
    byType: Record<string, number>;
    averageSignificance: number;
    qualityScore: number;
  };
  validationReport: {
    structureCompliance: number;
    contentQuality: number;
    templateAdherence: number;
    issues: string[];
  };
}

export class ObservationGenerationAgent {
  private templates: Map<string, ObservationTemplate[]> = new Map();
  private repositoryPath: string;
  private semanticAnalyzer: SemanticAnalyzer;
  private team: string;

  constructor(repositoryPath: string = '.', team: string = 'coding') {
    this.repositoryPath = repositoryPath;
    this.team = team;
    this.semanticAnalyzer = new SemanticAnalyzer();
    this.initializeTemplates();
  }

  /**
   * Check if an insight document file exists
   * Used to only add "Details:" links when the file actually exists
   */
  private insightFileExists(entityName: string): boolean {
    const insightsDir = path.join(this.repositoryPath, 'knowledge-management', 'insights');
    const filePath = path.join(insightsDir, `${entityName}.md`);
    try {
      return fs.existsSync(filePath);
    } catch {
      return false;
    }
  }

  async generateStructuredObservations(
    gitAnalysis: any,
    vibeAnalysis: any,
    semanticAnalysis: any,
    webSearchResults?: any
  ): Promise<ObservationGenerationResult> {
    // Handle both direct parameters and coordinator parameter object
    let actualGitAnalysis = gitAnalysis;
    let actualVibeAnalysis = vibeAnalysis;
    let actualSemanticAnalysis = semanticAnalysis;
    let actualWebSearchResults = webSearchResults;
    let insightsResults: any = null;
    
    // Check if called with single parameter object from coordinator
    if (arguments.length === 1 && typeof gitAnalysis === 'object' && 
        (gitAnalysis.git_analysis_results || gitAnalysis.insights_results)) {
      const params = gitAnalysis;
      actualGitAnalysis = params.git_analysis_results || params.gitAnalysis;
      actualVibeAnalysis = params.vibe_analysis_results || params.vibeAnalysis;
      actualSemanticAnalysis = params.semantic_analysis_results || params.semanticAnalysis;
      actualWebSearchResults = params.web_search_results || params.webSearchResults;
      insightsResults = params.insights_results || params.insights;
      
      log('Detected coordinator parameter format', 'info', {
        hasGitAnalysis: !!actualGitAnalysis,
        hasVibeAnalysis: !!actualVibeAnalysis,
        hasSemanticAnalysis: !!actualSemanticAnalysis,
        hasInsightsResults: !!insightsResults
      });
    }
    
    log('Starting structured observation generation', 'info', {
      gitCommits: actualGitAnalysis?.commits?.length || 0,
      vibeSessions: actualVibeAnalysis?.sessions?.length || 0,
      hasSemanticAnalysis: !!actualSemanticAnalysis,
      hasInsightsResults: !!insightsResults
    });

    try {
      const observations: StructuredObservation[] = [];

      // Generate observations from git analysis
      if (actualGitAnalysis) {
        const gitObservations = await this.generateFromGitAnalysis(actualGitAnalysis);
        observations.push(...gitObservations);
      }

      // Generate observations from vibe analysis
      if (actualVibeAnalysis) {
        const vibeObservations = await this.generateFromVibeAnalysis(actualVibeAnalysis);
        observations.push(...vibeObservations);
      }

      // Generate observations from semantic analysis
      if (actualSemanticAnalysis) {
        const semanticObservations = await this.generateFromSemanticAnalysis(actualSemanticAnalysis);
        observations.push(...semanticObservations);
      }
      
      // Generate observations from insights results
      if (insightsResults) {
        const insightObservations = await this.generateFromInsightsResults(insightsResults);
        observations.push(...insightObservations);
        log(`Generated ${insightObservations.length} observations from insights`, 'info');
      }

      // Generate cross-analysis observations
      const crossObservations = await this.generateCrossAnalysisObservations(
        actualGitAnalysis, actualVibeAnalysis, actualSemanticAnalysis
      );
      observations.push(...crossObservations);

      // Enhance with web search results
      if (actualWebSearchResults) {
        await this.enhanceWithWebSearch(observations, actualWebSearchResults);
      }

      // Validate observations
      const validationReport = this.validateObservations(observations);

      // Generate summary
      const summary = this.generateSummary(observations);

      log('Structured observation generation completed', 'info', {
        totalObservations: observations.length,
        averageSignificance: summary.averageSignificance,
        qualityScore: validationReport.contentQuality
      });

      return {
        observations,
        summary,
        validationReport
      };

    } catch (error) {
      log('Observation generation failed', 'error', error);
      throw error;
    }
  }

  private initializeTemplates(): void {
    // Based on existing patterns in knowledge-export/coding.json
    
    // Rule template - critical guidelines
    this.templates.set('rule', [
      {
        type: 'rule',
        content: 'Always follow established pattern for consistent implementation',
        date: new Date().toISOString(),
        metadata: { category: 'guideline', enforcement: 'strict' }
      }
    ]);

    // Implementation template - how it's done
    this.templates.set('implementation', [
      {
        type: 'implementation',
        content: 'Specific technical approach and methods used',
        date: new Date().toISOString(),
        metadata: { technical: true, reusable: true }
      }
    ]);

    // Insight template - key learnings
    this.templates.set('insight', [
      {
        type: 'insight',
        content: 'Important understanding or realization from the experience',
        date: new Date().toISOString(),
        metadata: { transferable: true, impact: 'high' }
      }
    ]);

    // Applicability template - where it applies
    this.templates.set('applicability', [
      {
        type: 'applicability',
        content: 'Contexts and scenarios where this pattern applies',
        date: new Date().toISOString(),
        metadata: { scope: 'broad', generalizability: 'high' }
      }
    ]);

    // Link template - references to detailed docs
    this.templates.set('link', [
      {
        type: 'link',
        content: 'Details: http://localhost:8080/knowledge-management/insights/PatternName.md',
        date: new Date().toISOString(),
        metadata: { source: 'documentation', type: 'reference' }
      }
    ]);

    // Metric template - measurable outcomes
    this.templates.set('metric', [
      {
        type: 'metric',
        content: 'Quantifiable results and performance indicators',
        date: new Date().toISOString(),
        metadata: { measurable: true, trackable: true }
      }
    ]);
  }

  private async generateFromGitAnalysis(gitAnalysis: any): Promise<StructuredObservation[]> {
    const observations: StructuredObservation[] = [];

    // Generate observations for architectural decisions
    if (gitAnalysis.architecturalDecisions) {
      for (const decision of gitAnalysis.architecturalDecisions) {
        const observation = await this.createArchitecturalDecisionObservation(decision, gitAnalysis);
        if (observation) observations.push(observation);
      }
    }

    // Generate observations for code evolution patterns
    if (gitAnalysis.codeEvolution) {
      for (const pattern of gitAnalysis.codeEvolution.slice(0, 5)) { // Top 5 patterns
        const observation = await this.createCodeEvolutionObservation(pattern, gitAnalysis);
        if (observation) observations.push(observation);
      }
    }

    return observations;
  }

  private async createArchitecturalDecisionObservation(
    decision: any, 
    gitAnalysis: any
  ): Promise<StructuredObservation | null> {
    try {
      const entityName = this.generateEntityName(decision.type, decision.description);
      const currentDate = new Date().toISOString();

      // Create actionable observations with concrete guidance (avoid template garbage patterns)
      const keyFiles = decision.files.slice(0, 3).map((f: string) => '`' + f.split('/').pop() + '`').join(', ');
      const technologies = this.extractTechnologiesFromFiles(decision.files);
      const techList = technologies.length > 0 ? technologies.join(', ') : 'TypeScript';

      const observations: (string | ObservationTemplate)[] = [
        {
          type: 'problem',
          content: `When working with ${decision.type} in this codebase, changes often span multiple modules. Key files: ${keyFiles}`,
          date: currentDate
        },
        {
          type: 'solution',
          content: `${decision.description}. This pattern was established to ${this.inferDecisionRationale(decision.type, decision.impact)}`,
          date: currentDate
        },
        {
          type: 'learning',
          content: `DO: Check ${keyFiles} when modifying ${decision.type} behavior. DON'T: Make isolated changes without verifying related modules`,
          date: currentDate
        },
        {
          type: 'applicability',
          content: `This ${decision.type} pattern is applicable when building ${techList} systems with ${decision.impact === 'high' ? 'critical' : 'standard'} reliability requirements`,
          date: currentDate
        }
      ];

      // Only add Details link if the insight file actually exists
      if (this.insightFileExists(entityName)) {
        observations.push({
          type: 'link',
          content: `Details: http://localhost:8080/knowledge-management/insights/${entityName}.md`,
          date: currentDate
        });
      }

      return {
        name: entityName,
        entityType: 'Unclassified',  // Will be classified by ontology-classification-agent
        significance: this.calculateSignificance(decision.impact, decision.files.length),
        observations,
        // HIERARCHICAL STRUCTURE: Topics link to Projects only
        // CollectiveKnowledge -> includes -> Projects (handled by GraphDatabaseService)
        relationships: [
          {
            from: entityName,
            to: 'Coding',
            relationType: 'implemented in'
          }
        ],
        metadata: {
          created_at: currentDate,
          last_updated: currentDate,
          created_by: 'semantic-analysis-agent',
          version: '1.0',
          team: this.team
        }
      };

    } catch (error) {
      log('Failed to create architectural decision observation', 'error', error);
      return null;
    }
  }

  private async createCodeEvolutionObservation(
    pattern: any,
    gitAnalysis: any
  ): Promise<StructuredObservation | null> {
    try {
      const entityName = this.generateEntityName('CodeEvolution', pattern.pattern);
      const currentDate = new Date().toISOString();

      // Create actionable code evolution observations
      const keyFiles = pattern.files.slice(0, 3).map((f: string) => '`' + f.split('/').pop() + '`').join(', ');
      const trendGuidance = this.interpretTrend(pattern.trend, pattern.pattern);

      const observations: ObservationTemplate[] = [
        {
          type: 'problem',
          content: `Development teams frequently apply ${pattern.pattern} when modifying ${keyFiles}. Understanding this pattern improves code review efficiency`,
          date: currentDate,
          metadata: {
            frequency: pattern.occurrences,
            trend: pattern.trend
          }
        },
        {
          type: 'solution',
          content: `DO: Follow the ${pattern.pattern} approach when editing these files. DON'T: Deviate without team discussion`,
          date: currentDate,
          metadata: {
            approach: pattern.pattern,
            consistency: pattern.occurrences > 3 ? 'high' : 'medium'
          }
        },
        {
          type: 'learning',
          content: `${trendGuidance}. Key touchpoints: ${keyFiles}`,
          date: currentDate,
          metadata: {
            transferable: true,
            domain: 'development-process'
          }
        }
      ];

      return {
        name: entityName,
        entityType: 'Unclassified',  // Will be classified by ontology-classification-agent
        significance: Math.min(Math.ceil(pattern.occurrences / 2), 10),
        observations,
        tags: [pattern.pattern.replace(/\s+/g, ''), pattern.trend, 'evolution', 'git-analysis'],
        relationships: [
          {
            from: entityName,
            to: 'GitHistoryAnalysis',
            relationType: 'evidencedBy',
            type: 'evidencedBy',
            target: 'GitHistoryAnalysis',
            description: `Pattern observed across ${pattern.commits.length} commits`
          }
        ],
        metadata: {
          created_at: currentDate,
          last_updated: currentDate,
          generatedAt: currentDate,
          sourceData: ['git-history'],
          confidence: 0.8,
          validationStatus: 'pending'
        }
      };

    } catch (error) {
      log('Failed to create code evolution observation', 'error', error);
      return null;
    }
  }

  private async generateFromVibeAnalysis(vibeAnalysis: any): Promise<StructuredObservation[]> {
    const observations: StructuredObservation[] = [];

    // Generate observations for problem-solution pairs
    if (vibeAnalysis.problemSolutionPairs) {
      for (const pair of vibeAnalysis.problemSolutionPairs.slice(0, 10)) { // Top 10 pairs
        const observation = await this.createProblemSolutionObservation(pair, vibeAnalysis);
        if (observation) observations.push(observation);
      }
    }

    // Generate observations for development contexts
    if (vibeAnalysis.developmentContexts) {
      const contextGroups = this.groupContextsByType(vibeAnalysis.developmentContexts);
      for (const [type, contexts] of contextGroups.entries()) {
        const observation = await this.createContextGroupObservation(type, contexts, vibeAnalysis);
        if (observation) observations.push(observation);
      }
    }

    return observations;
  }

  private async createProblemSolutionObservation(
    pair: any,
    vibeAnalysis: any
  ): Promise<StructuredObservation | null> {
    try {
      const entityName = this.generateEntityName('ProblemSolution', pair.problem.description);
      const currentDate = new Date().toISOString();

      // Create actionable observations from problem-solution pairs
      const techList = pair.solution.technologies.slice(0, 3).map((t: string) => '`' + t + '`').join(', ');
      const stepSummary = pair.solution.steps.length > 2 ? 'multi-step systematic' : 'direct focused';

      const observations: (string | ObservationTemplate)[] = [
        {
          type: 'problem',
          content: pair.problem.description,
          date: currentDate
        },
        {
          type: 'solution',
          content: `DO: Apply ${pair.solution.approach} using ${techList}. This ${stepSummary} approach achieved: ${pair.solution.outcome}`,
          date: currentDate
        },
        {
          type: 'learning',
          content: `When facing ${pair.problem.difficulty}-difficulty problems, ${pair.solution.steps.length > 2 ? 'break down into smaller steps' : 'tackle directly'}. Key tools: ${techList}`,
          date: currentDate
        }
      ];

      // Only add Details link if the insight file actually exists
      if (this.insightFileExists(entityName)) {
        observations.push({
          type: 'link',
          content: `Details: http://localhost:8080/knowledge-management/insights/${entityName}.md`,
          date: currentDate
        });
      }

      return {
        name: entityName,
        entityType: 'Unclassified',  // Will be classified by ontology-classification-agent
        significance: this.calculateSignificanceFromDifficulty(pair.problem.difficulty),
        observations,
        // HIERARCHICAL STRUCTURE: Topics link to Projects only
        relationships: [
          {
            from: entityName,
            to: 'Coding',
            relationType: 'implemented in'
          }
        ],
        metadata: {
          created_at: currentDate,
          last_updated: currentDate,
          created_by: 'semantic-analysis-agent',
          version: '1.0',
          team: this.team
        }
      };

    } catch (error) {
      log('Failed to create problem-solution observation', 'error', error);
      return null;
    }
  }

  private groupContextsByType(contexts: any[]): Map<string, any[]> {
    const groups = new Map<string, any[]>();
    
    contexts.forEach(context => {
      const type = context.problemType || 'General';
      if (!groups.has(type)) {
        groups.set(type, []);
      }
      groups.get(type)!.push(context);
    });

    return groups;
  }

  private async createContextGroupObservation(
    type: string,
    contexts: any[],
    vibeAnalysis: any
  ): Promise<StructuredObservation | null> {
    try {
      const entityName = this.generateEntityName('DevelopmentContext', type);
      const currentDate = new Date().toISOString();

      const totalContexts = contexts.length;
      const commonTechnologies = this.extractCommonTechnologies(contexts);
      const successfulOutcomes = contexts.filter(c => c.outcomes.length > 0).length;

      // Create actionable development context observations
      const techList = commonTechnologies.slice(0, 3).map(t => '`' + t + '`').join(', ');
      const successRate = Math.round((successfulOutcomes / totalContexts) * 100);

      const observations: ObservationTemplate[] = [
        {
          type: 'problem',
          content: `When working on ${type} tasks, developers in this codebase commonly use ${techList}`,
          date: currentDate,
          metadata: {
            frequency: totalContexts,
            type: type
          }
        },
        {
          type: 'solution',
          content: `DO: For ${type} work, start with ${commonTechnologies[0] || 'established patterns'}. ${successRate > 70 ? 'This approach has a strong success rate.' : 'Consider reviewing past outcomes for improvements.'}`,
          date: currentDate,
          metadata: {
            approach: type,
            successRate: successRate
          }
        },
        {
          type: 'learning',
          content: `${type} tasks in this project typically succeed when using ${techList}. DON'T: Introduce unfamiliar tools without team buy-in`,
          date: currentDate,
          metadata: {
            transferable: true,
            domain: 'development-workflow'
          }
        }
      ];

      return {
        name: entityName,
        entityType: 'Unclassified',  // Will be classified by ontology-classification-agent
        significance: Math.min(Math.ceil(totalContexts / 2), 8),
        observations,
        tags: [type.replace(/\s+/g, ''), 'context', 'workflow', 'vibe-analysis'],
        relationships: [
          {
            from: entityName,
            to: 'VibeHistoryAnalysis',
            relationType: 'aggregatedFrom',
            type: 'aggregatedFrom',
            target: 'VibeHistoryAnalysis',
            description: `Aggregated from ${totalContexts} development contexts`
          }
        ],
        metadata: {
          created_at: currentDate,
          last_updated: currentDate,
          generatedAt: currentDate,
          sourceData: ['vibe-history'],
          team: this.team,
          confidence: 0.85,
          validationStatus: 'pending'
        }
      };

    } catch (error) {
      log('Failed to create context group observation', 'error', error);
      return null;
    }
  }

  private async generateFromSemanticAnalysis(semanticAnalysis: any): Promise<StructuredObservation[]> {
    const observations: StructuredObservation[] = [];

    // Generate observations for key insights
    if (semanticAnalysis.insights) {
      const insights = Array.isArray(semanticAnalysis.insights) 
        ? semanticAnalysis.insights 
        : [semanticAnalysis.insights];

      for (const insight of insights.slice(0, 5)) {
        const observation = await this.createSemanticInsightObservation(insight, semanticAnalysis);
        if (observation) observations.push(observation);
      }
    }

    return observations;
  }

  private async generateFromInsightsResults(insightsResults: any): Promise<StructuredObservation[]> {
    const observations: StructuredObservation[] = [];
    
    log('Processing insights results', 'info', {
      hasInsightDocument: !!insightsResults?.insightDocument,
      hasInsightDocuments: !!insightsResults?.insightDocuments,
      insightDocumentsCount: insightsResults?.insightDocuments?.length || 0,
      hasPatternCatalog: !!insightsResults?.patternCatalog
    });
    
    // Process multiple insight documents if available
    if (insightsResults?.insightDocuments && Array.isArray(insightsResults.insightDocuments)) {
      for (const insightDoc of insightsResults.insightDocuments) {
        const observation = await this.createInsightDocumentObservation(insightDoc);
        if (observation) {
          observations.push(observation);
          log(`Created observation for insight: ${insightDoc.name}`, 'info');
        }
      }
    } 
    // Process single insight document if available
    else if (insightsResults?.insightDocument) {
      const observation = await this.createInsightDocumentObservation(insightsResults.insightDocument);
      if (observation) {
        observations.push(observation);
      }
    }
    
    // Process pattern catalog if available
    if (insightsResults?.patternCatalog?.patterns) {
      for (const pattern of insightsResults.patternCatalog.patterns) {
        const observation = await this.createPatternObservation(pattern);
        if (observation) {
          observations.push(observation);
        }
      }
    }
    
    return observations;
  }
  
  private async createInsightDocumentObservation(insightDoc: any): Promise<StructuredObservation | null> {
    try {
      const currentDate = new Date().toISOString();
      const cleanName = insightDoc.name || 'UnknownInsight';

      const observations: ObservationTemplate[] = [
        {
          type: 'insight',
          content: `${cleanName} - ${insightDoc.title || 'Comprehensive Pattern Analysis'}`,
          date: currentDate,
          metadata: {
            transferable: true,
            domain: 'pattern-analysis',
            significance: insightDoc.metadata?.significance || 8
          }
        },
        {
          type: 'solution',
          content: insightDoc.content?.substring(0, 500) || 'Pattern implementation and analysis',
          date: currentDate,
          metadata: {
            technical: true,
            patterns: insightDoc.metadata?.tags || []
          }
        }
      ];

      // Only add Details link if the insight file actually exists
      if (this.insightFileExists(cleanName)) {
        observations.push({
          type: 'link',
          content: `Details: http://localhost:8080/knowledge-management/insights/${cleanName}.md`,
          date: currentDate,
          metadata: {
            source: 'insight-generation',
            fileValidated: true
          }
        });
      }
      
      // Add metrics if available
      if (insightDoc.metadata?.patternCount) {
        observations.push({
          type: 'metric',
          content: `Pattern analysis identified ${insightDoc.metadata.patternCount} distinct patterns`,
          date: currentDate,
          metadata: {
            count: insightDoc.metadata.patternCount,
            analysisTypes: insightDoc.metadata.analysisTypes || []
          }
        });
      }

      // Add diagram link observations for each generated diagram
      if (insightDoc.diagrams && Array.isArray(insightDoc.diagrams)) {
        for (const diagram of insightDoc.diagrams) {
          if (diagram.success && diagram.pngFile) {
            observations.push({
              type: 'link',
              content: `${diagram.type} diagram: ${diagram.pngFile}`,
              date: currentDate,
              metadata: {
                diagramType: diagram.type,
                pumlFile: diagram.pumlFile,
                pngFile: diagram.pngFile,
                source: 'insight-generation'
              }
            });
          }
        }
      }

      return {
        name: cleanName,
        entityType: 'Unclassified',  // Will be classified by ontology-classification-agent
        significance: insightDoc.metadata?.significance || 8,
        observations,
        tags: insightDoc.metadata?.tags || ['pattern', 'insight', 'analysis'],
        relationships: [],
        metadata: {
          created_at: currentDate,
          last_updated: currentDate,
          created_by: 'insight-generation-agent',
          version: '1.0',
          team: this.team,
          generatedAt: insightDoc.metadata?.generatedAt || currentDate,
          sourceData: {
            analysisTypes: insightDoc.metadata?.analysisTypes || [],
            patternCount: insightDoc.metadata?.patternCount || 0
          }
        }
      };
    } catch (error) {
      log('Failed to create insight document observation', 'error', error);
      return null;
    }
  }
  
  private async createPatternObservation(pattern: any): Promise<StructuredObservation | null> {
    try {
      const currentDate = new Date().toISOString();
      const patternName = pattern.name || 'UnknownPattern';
      
      const observations: ObservationTemplate[] = [
        {
          type: 'insight',
          content: pattern.description || 'Pattern identified through analysis',
          date: currentDate,
          metadata: {
            category: pattern.category,
            significance: pattern.significance
          }
        }
      ];
      
      // Add implementation details if available
      if (pattern.implementation) {
        observations.push({
          type: 'implementation',
          content: pattern.implementation.codeExample || pattern.implementation.usageNotes?.join('; ') || 'Implementation details',
          date: currentDate,
          metadata: {
            language: pattern.implementation.language,
            reusable: true
          }
        });
      }
      
      // Add evidence if available
      if (pattern.evidence && pattern.evidence.length > 0) {
        observations.push({
          type: 'validation',
          content: `Evidence: ${pattern.evidence.slice(0, 3).join('; ')}`,
          date: currentDate,
          metadata: {
            evidenceCount: pattern.evidence.length
          }
        });
      }
      
      return {
        name: patternName,
        entityType: 'Unclassified',  // Will be classified by ontology-classification-agent
        significance: pattern.significance || 5,
        observations,
        tags: [pattern.category, 'pattern', ...pattern.relatedComponents || []],
        relationships: pattern.relatedComponents?.map((comp: string) => ({
          from: patternName,
          to: comp,
          relationType: 'relatesTo',
          type: 'relatesTo',
          target: comp
        })) || [],
        metadata: {
          created_at: currentDate,
          last_updated: currentDate,
          created_by: 'pattern-analysis',
          version: '1.0',
          team: this.team
        }
      };
    } catch (error) {
      log('Failed to create pattern observation', 'error', error);
      return null;
    }
  }

  /**
   * Pre-validation: Check if insight input is meaningful before creating entity
   * Rejects garbage inputs like keyword-only definitions, generic statements, etc.
   */
  private isValidInsightInput(insightText: string): { valid: boolean; reason?: string } {
    // Reject empty or too short
    if (!insightText || insightText.trim().length < 30) {
      return { valid: false, reason: 'Too short to be meaningful insight' };
    }

    // Reject keyword-only definitions (e.g., "api: Handles external communication")
    const keywordPattern = /^[a-zA-Z_-]+:\s+.{0,60}$/;
    if (keywordPattern.test(insightText.trim())) {
      return { valid: false, reason: 'Keyword-only definition, not a meaningful insight' };
    }

    // Reject generic/boilerplate patterns
    const genericPatterns = [
      /^General\s/i,
      /^No (theme|pattern|data|insight)/i,
      /\(\d+\s*occurrences?\)/i,
      /^Semantic insight$/i,
      /^Unknown/i,
      /^Undefined/i,
      /^Various/i,
      /^Multiple/i,
      /^Miscellaneous/i,
    ];
    for (const pattern of genericPatterns) {
      if (pattern.test(insightText.trim())) {
        return { valid: false, reason: `Matches generic pattern: ${pattern}` };
      }
    }

    // Reject insights that are just listing concepts without substance
    const wordCount = insightText.split(/\s+/).length;
    if (wordCount < 8 && !insightText.includes('`') && !insightText.includes('()')) {
      return { valid: false, reason: 'Too few words and no code references' };
    }

    // Require minimum substance: either 100+ chars or contains code refs
    const hasCodeRef = /[`\(\)\.\/]|function|class|method|import|export|const|let|var/i.test(insightText);
    if (insightText.length < 100 && !hasCodeRef) {
      return { valid: false, reason: 'Insufficient substance (< 100 chars, no code references)' };
    }

    return { valid: true };
  }

  /**
   * Generate a clean entity name, rejecting garbage inputs
   */
  private generateCleanEntityName(description: string): string | null {
    // Reject garbage before generating name
    const validation = this.isValidInsightInput(description);
    if (!validation.valid) {
      log('Rejected garbage input for entity name', 'debug', {
        reason: validation.reason,
        input: description.substring(0, 80)
      });
      return null;
    }

    // Extract meaningful words, skip common filler words
    const fillerWords = new Set(['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'from', 'is', 'are', 'was', 'were', 'be', 'been', 'being', 'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could', 'should', 'may', 'might', 'must', 'shall', 'can', 'this', 'that', 'these', 'those', 'it', 'its']);

    const words = description
      .replace(/[^a-zA-Z0-9\s]/g, ' ')
      .trim()
      .split(/\s+/)
      .filter(word => word.length > 2 && !fillerWords.has(word.toLowerCase()))
      .slice(0, 4)
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase());

    if (words.length < 2) {
      return null; // Not enough meaningful words
    }

    // Don't prefix with "SemanticInsight" - let ontology classify the type
    return words.join('');
  }

  private async createSemanticInsightObservation(
    insight: any,
    semanticAnalysis: any
  ): Promise<StructuredObservation | null> {
    try {
      const insightText = typeof insight === 'string' ? insight : insight.description || 'Semantic insight';

      // Phase 1.2: Pre-validate before creating entity
      const validation = this.isValidInsightInput(insightText);
      if (!validation.valid) {
        log('Skipping garbage insight', 'debug', {
          reason: validation.reason,
          preview: insightText.substring(0, 100)
        });
        return null;
      }

      // Phase 1.3: Generate clean entity name (may return null for garbage)
      const entityName = this.generateCleanEntityName(insightText);
      if (!entityName) {
        log('Could not generate meaningful entity name', 'debug', {
          preview: insightText.substring(0, 100)
        });
        return null;
      }
      const currentDate = new Date().toISOString();

      // ENHANCEMENT: Use LLM to extract deeper insights and categorization
      let enhancedInsights: any = null;
      try {
        const prompt = `Analyze this technical insight and extract structured information:

Insight: ${insightText}

Provide a JSON response with:
{
  "keyLearnings": string[], // 2-3 specific actionable learnings
  "technicalDomain": string, // e.g., "architecture", "performance", "security"
  "applicabilityScope": string, // Who can benefit from this
  "confidence": number, // 0-1
  "actionableRecommendations": string[] // 2-3 specific recommendations
}`;

        const result = await this.semanticAnalyzer.analyzeContent(prompt, {
          analysisType: "general",
          provider: "auto",
          taskType: "observation_generation"  // Uses premium tier for quality observations
        });

        enhancedInsights = JSON.parse(result.insights);
        log("LLM-enhanced insight extraction completed", "info", {
          domain: enhancedInsights.technicalDomain,
          confidence: enhancedInsights.confidence
        });
      } catch (error) {
        log("LLM insight enhancement failed, using template-based approach", "warning", error);
      }

      // Only include observations with actual meaningful content - no hardcoded boilerplate
      const observations: ObservationTemplate[] = [];

      // Add learning observation only if we have meaningful content
      const learningContent = enhancedInsights?.keyLearnings?.join('. ') || insightText;
      if (learningContent && learningContent.length > 50) {
        observations.push({
          type: 'learning',
          content: learningContent,
          date: currentDate,
          metadata: {
            transferable: true,
            domain: enhancedInsights?.technicalDomain || 'semantic-analysis',
            confidence: enhancedInsights?.confidence || 0.7
          }
        });
      }

      // Add actionable recommendations if available
      if (enhancedInsights?.actionableRecommendations) {
        enhancedInsights.actionableRecommendations.forEach((recommendation: string) => {
          observations.push({
            type: 'implementation',
            content: recommendation,
            date: currentDate,
            metadata: {
              priority: 'medium',
              actionable: true
            }
          });
        });
      }

      return {
        name: entityName,
        entityType: 'Unclassified',  // Will be classified by ontology-classification-agent
        significance: 7, // Default high significance for semantic insights
        observations,
        tags: ['semantic', 'insight', 'analysis', 'cross-source'],
        relationships: [
          {
            from: entityName,
            to: 'SemanticAnalysis',
            relationType: 'derivedFrom',
            type: 'derivedFrom',
            target: 'SemanticAnalysis',
            description: 'Generated through semantic analysis of multiple data sources'
          }
        ],
        metadata: {
          created_at: currentDate,
          last_updated: currentDate,
          generatedAt: currentDate,
          sourceData: ['semantic-analysis'],
          confidence: 0.88,
          validationStatus: 'pending'
        }
      };

    } catch (error) {
      log('Failed to create semantic insight observation', 'error', error);
      return null;
    }
  }

  private async generateCrossAnalysisObservations(
    gitAnalysis: any,
    vibeAnalysis: any,
    semanticAnalysis: any
  ): Promise<StructuredObservation[]> {
    const observations: StructuredObservation[] = [];

    // Correlate git patterns with conversation patterns
    if (gitAnalysis?.codeEvolution && vibeAnalysis?.patterns?.developmentThemes) {
      const correlation = this.correlatePatternsAcrossSources(
        gitAnalysis.codeEvolution,
        vibeAnalysis.patterns.developmentThemes
      );

      if (correlation) {
        observations.push(correlation);
      }
    }

    return observations;
  }

  private correlatePatternsAcrossSources(
    gitPatterns: any[],
    vibeThemes: any[]
  ): StructuredObservation | null {
    // DISABLED: This method was generating garbage observations like:
    // "Correlation identified between git activity (promise) and conversation focus (No theme)"
    //
    // The approach of template-filling raw data produces meaningless entities that:
    // 1. Have broken entity names (e.g., "CrossanalysisGitvibecorrelationPattern")
    // 2. Contain no actionable insights for developers
    // 3. Waste storage and attention in the knowledge graph
    //
    // TODO: If cross-source correlation is needed, use LLM to:
    // 1. Actually analyze both sources semantically
    // 2. Identify real patterns that span git commits AND conversations
    // 3. Generate specific, actionable observations with code references
    // 4. Create proper entity names based on the actual correlation found
    //
    // Until that's implemented, return null to avoid generating garbage.
    log('Skipping cross-analysis correlation (disabled - was generating garbage)', 'info', {
      gitPatternsCount: gitPatterns?.length || 0,
      vibeThemesCount: vibeThemes?.length || 0
    });
    return null;

    // Original garbage-generating code preserved for reference:
    /*
    try {
      const entityName = this.generateEntityName('CrossAnalysis', 'GitVibeCorrelation');
      const currentDate = new Date().toISOString();

      const topGitPattern = gitPatterns[0]?.pattern || 'No pattern';
      const topVibeTheme = vibeThemes[0]?.theme || 'No theme';

      const observations: ObservationTemplate[] = [
        {
          type: 'learning',
          content: `Correlation identified between git activity (${topGitPattern}) and conversation focus (${topVibeTheme})`,
          date: currentDate,
          metadata: {
            transferable: true,
            domain: 'cross-analysis'
          }
        },
        {
          type: 'rationale',
          content: 'Cross-source analysis reveals alignment between code changes and development discussions',
          date: currentDate,
          metadata: {
            factors: ['git-analysis', 'conversation-analysis', 'pattern-correlation'],
            tradeoffs: ['comprehensive view', 'complex analysis']
          }
        },
        {
          type: 'applicability',
          content: 'Pattern applicable to projects with active development and documentation through conversations',
          date: currentDate,
          metadata: {
            scope: 'active-development',
            generalizability: 'medium'
          }
        }
      ];

      return {
        name: entityName,
        entityType: 'Unclassified',  // Will be classified by ontology-classification-agent
        significance: 8,
        observations,
        tags: ['cross-analysis', 'correlation', 'git-vibe', 'pattern'],
        relationships: [
          {
            from: entityName,
            to: 'GitHistoryAnalysis',
            relationType: 'correlates',
            type: 'correlates',
            target: 'GitHistoryAnalysis',
            description: 'Correlates git patterns with conversation themes'
          },
          {
            from: entityName,
            to: 'VibeHistoryAnalysis',
            relationType: 'correlates',
            type: 'correlates',
            target: 'VibeHistoryAnalysis',
            description: 'Correlates conversation themes with git patterns'
          }
        ],
        metadata: {
          created_at: currentDate,
          last_updated: currentDate,
          generatedAt: currentDate,
          sourceData: ['git-history', 'vibe-history'],
          team: this.team,
          confidence: 0.75,
          validationStatus: 'pending'
        }
      };

    } catch (error) {
      log('Failed to create cross-analysis observation', 'error', error);
      return null;
    }
    */
  }

  private async enhanceWithWebSearch(
    observations: StructuredObservation[],
    webSearchResults: any
  ): Promise<void> {
    // Add reference observations from web search results
    observations.forEach(observation => {
      if (webSearchResults?.references) {
        observation.observations.push({
          type: 'reference',
          content: `External resources: ${webSearchResults.references.slice(0, 3).join(', ')}`,
          date: new Date().toISOString(),
          metadata: {
            source: 'web-search',
            reliability: 'medium'
          }
        });
      }
    });
  }

  public validateObservations(observations: StructuredObservation[]): ObservationGenerationResult['validationReport'] {
    let structureCompliance = 0;
    let contentQuality = 0;
    let templateAdherence = 0;
    const issues: string[] = [];

    for (const observation of observations) {
      // Structure compliance
      const hasRequiredFields = !!(observation.name && observation.entityType && observation.observations);
      const hasValidSignificance = observation.significance >= 1 && observation.significance <= 10;
      const hasObservations = observation.observations.length > 0;
      
      if (hasRequiredFields && hasValidSignificance && hasObservations) {
        structureCompliance++;
      } else {
        issues.push(`${observation.name}: Structure compliance issues`);
      }

      // Content quality
      const hasSubstantialContent = observation.observations.some(obs => {
        if (typeof obs === 'string') return obs.length > 50;
        return obs.content.length > 50;
      });
      const hasVariedObservations = new Set(observation.observations.map(obs => {
        if (typeof obs === 'string') return 'simple';
        return obs.type;
      })).size > 1;
      
      if (hasSubstantialContent && hasVariedObservations) {
        contentQuality++;
      } else {
        issues.push(`${observation.name}: Content quality issues`);
      }

      // Template adherence
      const hasValidTypes = observation.observations.every(obs => {
        if (typeof obs === 'string') return true; // Simple strings are valid
        return ['problem', 'solution', 'rationale', 'learning', 'applicability', 'technology', 'reference', 'metric'].includes(obs.type);
      });
      const hasMetadata = observation.observations.every(obs => {
        if (typeof obs === 'string') return true; // Simple strings don't need metadata
        return obs.metadata;
      });
      
      if (hasValidTypes && hasMetadata) {
        templateAdherence++;
      } else {
        issues.push(`${observation.name}: Template adherence issues`);
      }
    }

    const total = observations.length || 1;
    return {
      structureCompliance: Math.round((structureCompliance / total) * 100),
      contentQuality: Math.round((contentQuality / total) * 100),
      templateAdherence: Math.round((templateAdherence / total) * 100),
      issues
    };
  }

  private generateSummary(observations: StructuredObservation[]): ObservationGenerationResult['summary'] {
    const byType: Record<string, number> = {};
    let totalSignificance = 0;

    observations.forEach(observation => {
      byType[observation.entityType] = (byType[observation.entityType] || 0) + 1;
      totalSignificance += observation.significance;
    });

    const averageSignificance = observations.length > 0 ? Math.round(totalSignificance / observations.length) : 0;
    
    // Calculate quality score based on various factors
    const avgObservationsPerEntity = observations.length > 0 
      ? observations.reduce((sum, obs) => sum + obs.observations.length, 0) / observations.length 
      : 0;
    const avgRelationships = observations.length > 0
      ? observations.reduce((sum, obs) => sum + obs.relationships.length, 0) / observations.length
      : 0;

    const qualityScore = Math.min(
      Math.round((averageSignificance / 10) * 40 + (avgObservationsPerEntity / 5) * 30 + (avgRelationships / 2) * 30),
      100
    );

    return {
      totalGenerated: observations.length,
      byType,
      averageSignificance,
      qualityScore
    };
  }

  // Helper methods
  private generateEntityName(type: string, description: string): string {
    // Create a clean, PascalCase entity name - DO NOT force "Pattern" suffix
    // Entity types are determined by ontology classification, not naming convention
    const cleaned = description
      .replace(/[^a-zA-Z0-9\s]/g, '')
      .trim()
      .split(/\s+/)
      .slice(0, 4) // Max 4 words for descriptive names
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join('');

    // Preserve original type casing (e.g., "SemanticInsight" stays "SemanticInsight")
    // Only capitalize first letter if not already PascalCase
    const typeFormatted = /^[A-Z]/.test(type) ? type : type.charAt(0).toUpperCase() + type.slice(1);

    // Combine type and description WITHOUT forcing "Pattern" suffix
    // The entity type (Pattern, Workflow, Evolution, etc.) is determined by ontology classification
    return `${typeFormatted}${cleaned}`;
  }

  private calculateSignificance(impact: string, fileCount: number): number {
    // Match existing significance patterns: mostly 5, sometimes 8-9 for critical
    switch (impact) {
      case 'high': 
        return fileCount > 15 ? 9 : 8; // 9 for very large changes, 8 for high impact
      case 'medium': 
        return 5; // Standard significance
      case 'low': 
        return 5; // Still valuable for knowledge base
      default: 
        return 5;
    }
  }

  private calculateSignificanceFromDifficulty(difficulty: string): number {
    // Match existing significance patterns
    switch (difficulty) {
      case 'high': return 8;
      case 'medium': return 5;
      case 'low': return 5; // Still valuable
      default: return 5;
    }
  }

  private extractTechnologiesFromFiles(files: string[]): string[] {
    const technologies = new Set<string>();

    files.forEach(file => {
      const ext = path.extname(file).toLowerCase();
      switch (ext) {
        case '.ts': technologies.add('TypeScript'); break;
        case '.js': technologies.add('JavaScript'); break;
        case '.json': technologies.add('JSON'); break;
        case '.md': technologies.add('Markdown'); break;
        case '.py': technologies.add('Python'); break;
        case '.yml':
        case '.yaml': technologies.add('YAML'); break;
      }
    });

    return Array.from(technologies);
  }

  /**
   * Infer the rationale behind an architectural decision based on type and impact.
   * Provides actionable context for why the pattern exists.
   */
  private inferDecisionRationale(decisionType: string, impact: string): string {
    const typeRationales: Record<string, string> = {
      'api': 'ensure consistent external interfaces and maintainable service contracts',
      'config': 'centralize configuration management and enable environment-specific overrides',
      'error': 'provide comprehensive error tracking and graceful failure recovery',
      'logging': 'enable observability and debugging across the distributed system',
      'auth': 'secure access control and identity verification throughout the application',
      'database': 'optimize data persistence and ensure transactional integrity',
      'cache': 'improve performance through strategic data caching',
      'test': 'maintain code quality through comprehensive automated testing',
      'promise': 'manage asynchronous operations and prevent callback complexity',
      'event': 'enable loose coupling through event-driven communication',
      'state': 'manage application state predictably and avoid data inconsistencies',
      'security': 'protect against common vulnerabilities and ensure data safety',
    };

    const lowerType = decisionType.toLowerCase();
    for (const [key, rationale] of Object.entries(typeRationales)) {
      if (lowerType.includes(key)) {
        return rationale;
      }
    }

    // Default rationale based on impact
    return impact === 'high'
      ? 'ensure system reliability and maintainability at scale'
      : 'maintain code consistency and developer experience';
  }

  private extractCommonTechnologies(contexts: any[]): string[] {
    const techCounts = new Map<string, number>();
    
    contexts.forEach(context => {
      if (context.technicalDetails) {
        context.technicalDetails.forEach((detail: string) => {
          if (detail.startsWith('Tool: ')) {
            const tool = detail.replace('Tool: ', '');
            techCounts.set(tool, (techCounts.get(tool) || 0) + 1);
          }
        });
      }
    });
    
    return Array.from(techCounts.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, 5)
      .map(([tech]) => tech);
  }

  private interpretTrend(trend: string, pattern: string): string {
    switch (trend) {
      case 'increasing':
        return `growing emphasis on ${pattern}`;
      case 'decreasing':
        return `reduced focus on ${pattern}`;
      case 'stable':
        return `consistent approach to ${pattern}`;
      default:
        return `ongoing ${pattern} activity`;
    }
  }
}