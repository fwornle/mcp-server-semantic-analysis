import * as fs from 'fs';
import * as path from 'path';
import crypto from 'crypto';
import { log } from '../logging.js';

export interface ObservationTemplate {
  type: 'rule' | 'implementation' | 'validation' | 'workflow' | 'benefits' | 'link' | 'insight' | 'metric' | 'applicability' | 'performance' | 'checklist' | 'critical_rules' | 'tools' | 'compliance';
  content: string;
  date: string;
  metadata?: Record<string, any>;
}

export interface StructuredObservation {
  name: string; // Matches existing pattern
  entityType: string;
  significance: number; // 1-10, but usually 5, 8, or 9
  observations: (string | ObservationTemplate)[]; // Can be simple strings or structured
  relationships: {
    from: string;
    to: string;
    relationType: string;
  }[];
  metadata: {
    created_at: string;
    last_updated: string;
    created_by?: string;
    version?: string;
    team?: string;
  };
  id?: string; // Will be generated by persistence layer
}

export interface ObservationGenerationResult {
  observations: StructuredObservation[];
  summary: {
    totalGenerated: number;
    byType: Record<string, number>;
    averageSignificance: number;
    qualityScore: number;
  };
  validationReport: {
    structureCompliance: number;
    contentQuality: number;
    templateAdherence: number;
    issues: string[];
  };
}

export class ObservationGenerationAgent {
  private templates: Map<string, ObservationTemplate[]> = new Map();
  private repositoryPath: string;

  constructor(repositoryPath: string = '.') {
    this.repositoryPath = repositoryPath;
    this.initializeTemplates();
  }

  async generateStructuredObservations(
    gitAnalysis: any,
    vibeAnalysis: any,
    semanticAnalysis: any,
    webSearchResults?: any
  ): Promise<ObservationGenerationResult> {
    log('Starting structured observation generation', 'info', {
      gitCommits: gitAnalysis?.commits?.length || 0,
      vibeSessions: vibeAnalysis?.sessions?.length || 0,
      hasSemanticAnalysis: !!semanticAnalysis
    });

    try {
      const observations: StructuredObservation[] = [];

      // Generate observations from git analysis
      if (gitAnalysis) {
        const gitObservations = await this.generateFromGitAnalysis(gitAnalysis);
        observations.push(...gitObservations);
      }

      // Generate observations from vibe analysis
      if (vibeAnalysis) {
        const vibeObservations = await this.generateFromVibeAnalysis(vibeAnalysis);
        observations.push(...vibeObservations);
      }

      // Generate observations from semantic analysis
      if (semanticAnalysis) {
        const semanticObservations = await this.generateFromSemanticAnalysis(semanticAnalysis);
        observations.push(...semanticObservations);
      }

      // Generate cross-analysis observations
      const crossObservations = await this.generateCrossAnalysisObservations(
        gitAnalysis, vibeAnalysis, semanticAnalysis
      );
      observations.push(...crossObservations);

      // Enhance with web search results
      if (webSearchResults) {
        await this.enhanceWithWebSearch(observations, webSearchResults);
      }

      // Validate observations
      const validationReport = this.validateObservations(observations);

      // Generate summary
      const summary = this.generateSummary(observations);

      log('Structured observation generation completed', 'info', {
        totalObservations: observations.length,
        averageSignificance: summary.averageSignificance,
        qualityScore: validationReport.contentQuality
      });

      return {
        observations,
        summary,
        validationReport
      };

    } catch (error) {
      log('Observation generation failed', 'error', error);
      throw error;
    }
  }

  private initializeTemplates(): void {
    // Based on existing patterns in shared-memory-coding.json
    
    // Rule template - critical guidelines
    this.templates.set('rule', [
      {
        type: 'rule',
        content: 'Always follow established pattern for consistent implementation',
        date: new Date().toISOString(),
        metadata: { category: 'guideline', enforcement: 'strict' }
      }
    ]);

    // Implementation template - how it's done
    this.templates.set('implementation', [
      {
        type: 'implementation',
        content: 'Specific technical approach and methods used',
        date: new Date().toISOString(),
        metadata: { technical: true, reusable: true }
      }
    ]);

    // Insight template - key learnings
    this.templates.set('insight', [
      {
        type: 'insight',
        content: 'Important understanding or realization from the experience',
        date: new Date().toISOString(),
        metadata: { transferable: true, impact: 'high' }
      }
    ]);

    // Applicability template - where it applies
    this.templates.set('applicability', [
      {
        type: 'applicability',
        content: 'Contexts and scenarios where this pattern applies',
        date: new Date().toISOString(),
        metadata: { scope: 'broad', generalizability: 'high' }
      }
    ]);

    // Link template - references to detailed docs
    this.templates.set('link', [
      {
        type: 'link',
        content: 'Details: http://localhost:8080/knowledge-management/insights/PatternName.md',
        date: new Date().toISOString(),
        metadata: { source: 'documentation', type: 'reference' }
      }
    ]);

    // Metric template - measurable outcomes
    this.templates.set('metric', [
      {
        type: 'metric',
        content: 'Quantifiable results and performance indicators',
        date: new Date().toISOString(),
        metadata: { measurable: true, trackable: true }
      }
    ]);
  }

  private async generateFromGitAnalysis(gitAnalysis: any): Promise<StructuredObservation[]> {
    const observations: StructuredObservation[] = [];

    // Generate observations for architectural decisions
    if (gitAnalysis.architecturalDecisions) {
      for (const decision of gitAnalysis.architecturalDecisions) {
        const observation = await this.createArchitecturalDecisionObservation(decision, gitAnalysis);
        if (observation) observations.push(observation);
      }
    }

    // Generate observations for code evolution patterns
    if (gitAnalysis.codeEvolution) {
      for (const pattern of gitAnalysis.codeEvolution.slice(0, 5)) { // Top 5 patterns
        const observation = await this.createCodeEvolutionObservation(pattern, gitAnalysis);
        if (observation) observations.push(observation);
      }
    }

    return observations;
  }

  private async createArchitecturalDecisionObservation(
    decision: any, 
    gitAnalysis: any
  ): Promise<StructuredObservation | null> {
    try {
      const entityName = this.generateEntityName(decision.type, decision.description);
      const currentDate = new Date().toISOString();

      // Create concise observations that match existing pattern
      const observations: (string | ObservationTemplate)[] = [
        `${decision.type} architectural decision involving ${decision.files.length} files with ${decision.impact} impact`,
        {
          type: 'implementation',
          content: `${decision.description} (commit: ${decision.commit})`,
          date: currentDate
        },
        {
          type: 'insight',
          content: `${decision.type} changes require careful coordination across ${decision.files.length} files`,
          date: currentDate
        },
        {
          type: 'applicability',
          content: `Similar ${decision.type} decisions in ${this.extractTechnologiesFromFiles(decision.files).join(', ')} projects`,
          date: currentDate
        },
        {
          type: 'metric',
          content: `Files: ${decision.files.length}, Impact: ${decision.impact}, Commit: ${decision.commit}`,
          date: currentDate
        },
        {
          type: 'link',
          content: `Details: http://localhost:8080/knowledge-management/insights/${entityName}.md`,
          date: currentDate
        }
      ];

      return {
        name: entityName,
        entityType: 'TransferablePattern',
        significance: this.calculateSignificance(decision.impact, decision.files.length),
        observations,
        relationships: [
          {
            from: entityName,
            to: 'CollectiveKnowledge',
            relationType: 'contributes to'
          },
          {
            from: entityName,
            to: 'Coding',
            relationType: 'implemented in'
          }
        ],
        metadata: {
          created_at: currentDate,
          last_updated: currentDate,
          created_by: 'semantic-analysis-agent',
          version: '1.0',
          team: 'coding'
        }
      };

    } catch (error) {
      log('Failed to create architectural decision observation', 'error', error);
      return null;
    }
  }

  private async createCodeEvolutionObservation(
    pattern: any,
    gitAnalysis: any
  ): Promise<StructuredObservation | null> {
    try {
      const entityName = this.generateEntityName('CodeEvolution', pattern.pattern);
      const currentDate = new Date().toISOString();

      const observations: ObservationTemplate[] = [
        {
          type: 'problem',
          content: `Recurring development pattern identified: ${pattern.pattern}`,
          date: currentDate,
          metadata: {
            frequency: pattern.occurrences,
            trend: pattern.trend
          }
        },
        {
          type: 'solution',
          content: `Consistent approach applied ${pattern.occurrences} times across ${pattern.files.length} files`,
          date: currentDate,
          metadata: {
            approach: pattern.pattern,
            consistency: pattern.occurrences > 3 ? 'high' : 'medium'
          }
        },
        {
          type: 'learning',
          content: `Pattern shows ${pattern.trend} trend, indicating ${this.interpretTrend(pattern.trend, pattern.pattern)}`,
          date: currentDate,
          metadata: {
            transferable: true,
            domain: 'development-process'
          }
        },
        {
          type: 'applicability',
          content: `Applies to similar ${pattern.pattern} scenarios in TypeScript/JavaScript projects`,
          date: currentDate,
          metadata: {
            scope: 'project-type',
            generalizability: 'high'
          }
        },
        {
          type: 'metric',
          content: `Occurrences: ${pattern.occurrences}, Files: ${pattern.files.length}, Trend: ${pattern.trend}`,
          date: currentDate,
          metadata: {
            quantifiable: true,
            baseline: pattern.occurrences,
            trend: pattern.trend
          }
        }
      ];

      return {
        entityName,
        entityType: 'CodeEvolutionPattern',
        significance: Math.min(Math.ceil(pattern.occurrences / 2), 10),
        observations,
        tags: [pattern.pattern.replace(/\s+/g, ''), pattern.trend, 'evolution', 'git-analysis'],
        relationships: [
          {
            type: 'evidencedBy',
            target: 'GitHistoryAnalysis',
            description: `Pattern observed across ${pattern.commits.length} commits`
          }
        ],
        metadata: {
          generatedAt: currentDate,
          sourceData: ['git-history'],
          confidence: 0.8,
          validationStatus: 'pending'
        }
      };

    } catch (error) {
      log('Failed to create code evolution observation', 'error', error);
      return null;
    }
  }

  private async generateFromVibeAnalysis(vibeAnalysis: any): Promise<StructuredObservation[]> {
    const observations: StructuredObservation[] = [];

    // Generate observations for problem-solution pairs
    if (vibeAnalysis.problemSolutionPairs) {
      for (const pair of vibeAnalysis.problemSolutionPairs.slice(0, 10)) { // Top 10 pairs
        const observation = await this.createProblemSolutionObservation(pair, vibeAnalysis);
        if (observation) observations.push(observation);
      }
    }

    // Generate observations for development contexts
    if (vibeAnalysis.developmentContexts) {
      const contextGroups = this.groupContextsByType(vibeAnalysis.developmentContexts);
      for (const [type, contexts] of contextGroups.entries()) {
        const observation = await this.createContextGroupObservation(type, contexts, vibeAnalysis);
        if (observation) observations.push(observation);
      }
    }

    return observations;
  }

  private async createProblemSolutionObservation(
    pair: any,
    vibeAnalysis: any
  ): Promise<StructuredObservation | null> {
    try {
      const entityName = this.generateEntityName('ProblemSolution', pair.problem.description);
      const currentDate = new Date().toISOString();

      // Create observations matching existing style - mix of strings and structured objects
      const observations: (string | ObservationTemplate)[] = [
        pair.problem.description.length > 100 ? pair.problem.description.substring(0, 100) + '...' : pair.problem.description,
        {
          type: 'implementation',
          content: `${pair.solution.approach} using ${pair.solution.technologies.join(', ')}`,
          date: currentDate
        },
        {
          type: 'insight',
          content: `${pair.problem.difficulty} difficulty problems benefit from ${pair.solution.steps.length > 2 ? 'systematic' : 'direct'} approach`,
          date: currentDate
        },
        {
          type: 'applicability',
          content: `Similar ${pair.problem.difficulty} difficulty development challenges in conversation-driven environments`,
          date: currentDate
        },
        {
          type: 'metric',
          content: `Solution steps: ${pair.solution.steps.length}, Technologies: ${pair.solution.technologies.length}, Outcome: ${pair.solution.outcome}`,
          date: currentDate
        },
        {
          type: 'link',
          content: `Details: http://localhost:8080/knowledge-management/insights/${entityName}.md`,
          date: currentDate
        }
      ];

      return {
        name: entityName,
        entityType: 'TransferablePattern',
        significance: this.calculateSignificanceFromDifficulty(pair.problem.difficulty),
        observations,
        relationships: [
          {
            from: entityName,
            to: 'CollectiveKnowledge',
            relationType: 'contributes to'
          },
          {
            from: entityName,
            to: 'Coding',
            relationType: 'implemented in'
          }
        ],
        metadata: {
          created_at: currentDate,
          last_updated: currentDate,
          created_by: 'semantic-analysis-agent',
          version: '1.0',
          team: 'coding'
        }
      };

    } catch (error) {
      log('Failed to create problem-solution observation', 'error', error);
      return null;
    }
  }

  private groupContextsByType(contexts: any[]): Map<string, any[]> {
    const groups = new Map<string, any[]>();
    
    contexts.forEach(context => {
      const type = context.problemType || 'General';
      if (!groups.has(type)) {
        groups.set(type, []);
      }
      groups.get(type)!.push(context);
    });

    return groups;
  }

  private async createContextGroupObservation(
    type: string,
    contexts: any[],
    vibeAnalysis: any
  ): Promise<StructuredObservation | null> {
    try {
      const entityName = this.generateEntityName('DevelopmentContext', type);
      const currentDate = new Date().toISOString();

      const totalContexts = contexts.length;
      const commonTechnologies = this.extractCommonTechnologies(contexts);
      const successfulOutcomes = contexts.filter(c => c.outcomes.length > 0).length;

      const observations: ObservationTemplate[] = [
        {
          type: 'problem',
          content: `Recurring development context: ${type} activities across ${totalContexts} conversation sessions`,
          date: currentDate,
          metadata: {
            frequency: totalContexts,
            type: type
          }
        },
        {
          type: 'solution',
          content: `Consistent approach patterns identified for ${type} problems`,
          date: currentDate,
          metadata: {
            approach: type,
            successRate: Math.round((successfulOutcomes / totalContexts) * 100)
          }
        },
        {
          type: 'learning',
          content: `${type} contexts show ${successfulOutcomes}/${totalContexts} success rate with common use of ${commonTechnologies.slice(0, 3).join(', ')}`,
          date: currentDate,
          metadata: {
            transferable: true,
            domain: 'development-workflow'
          }
        },
        {
          type: 'technology',
          content: commonTechnologies.join(', '),
          date: currentDate,
          metadata: {
            tools: commonTechnologies,
            contexts: totalContexts
          }
        },
        {
          type: 'metric',
          content: `Contexts: ${totalContexts}, Success rate: ${Math.round((successfulOutcomes / totalContexts) * 100)}%`,
          date: currentDate,
          metadata: {
            quantifiable: true,
            baseline: totalContexts,
            successRate: successfulOutcomes / totalContexts
          }
        }
      ];

      return {
        entityName,
        entityType: 'DevelopmentContextPattern',
        significance: Math.min(Math.ceil(totalContexts / 2), 8),
        observations,
        tags: [type.replace(/\s+/g, ''), 'context', 'workflow', 'vibe-analysis'],
        relationships: [
          {
            type: 'aggregatedFrom',
            target: 'VibeHistoryAnalysis',
            description: `Aggregated from ${totalContexts} development contexts`
          }
        ],
        metadata: {
          generatedAt: currentDate,
          sourceData: ['vibe-history'],
          confidence: 0.85,
          validationStatus: 'pending'
        }
      };

    } catch (error) {
      log('Failed to create context group observation', 'error', error);
      return null;
    }
  }

  private async generateFromSemanticAnalysis(semanticAnalysis: any): Promise<StructuredObservation[]> {
    const observations: StructuredObservation[] = [];

    // Generate observations for key insights
    if (semanticAnalysis.insights) {
      const insights = Array.isArray(semanticAnalysis.insights) 
        ? semanticAnalysis.insights 
        : [semanticAnalysis.insights];

      for (const insight of insights.slice(0, 5)) {
        const observation = await this.createSemanticInsightObservation(insight, semanticAnalysis);
        if (observation) observations.push(observation);
      }
    }

    return observations;
  }

  private async createSemanticInsightObservation(
    insight: any,
    semanticAnalysis: any
  ): Promise<StructuredObservation | null> {
    try {
      const insightText = typeof insight === 'string' ? insight : insight.description || 'Semantic insight';
      const entityName = this.generateEntityName('SemanticInsight', insightText);
      const currentDate = new Date().toISOString();

      const observations: ObservationTemplate[] = [
        {
          type: 'learning',
          content: insightText,
          date: currentDate,
          metadata: {
            transferable: true,
            domain: 'semantic-analysis'
          }
        },
        {
          type: 'rationale',
          content: 'Insight derived from semantic analysis of git and conversation history',
          date: currentDate,
          metadata: {
            factors: ['semantic-analysis', 'pattern-recognition', 'cross-source'],
            tradeoffs: ['comprehensive analysis', 'high confidence']
          }
        },
        {
          type: 'applicability',
          content: 'Applies to similar software development projects with rich commit and conversation history',
          date: currentDate,
          metadata: {
            scope: 'software-development',
            generalizability: 'high'
          }
        }
      ];

      return {
        entityName,
        entityType: 'SemanticInsight',
        significance: 7, // Default high significance for semantic insights
        observations,
        tags: ['semantic', 'insight', 'analysis', 'cross-source'],
        relationships: [
          {
            type: 'derivedFrom',
            target: 'SemanticAnalysis',
            description: 'Generated through semantic analysis of multiple data sources'
          }
        ],
        metadata: {
          generatedAt: currentDate,
          sourceData: ['semantic-analysis'],
          confidence: 0.88,
          validationStatus: 'pending'
        }
      };

    } catch (error) {
      log('Failed to create semantic insight observation', 'error', error);
      return null;
    }
  }

  private async generateCrossAnalysisObservations(
    gitAnalysis: any,
    vibeAnalysis: any,
    semanticAnalysis: any
  ): Promise<StructuredObservation[]> {
    const observations: StructuredObservation[] = [];

    // Correlate git patterns with conversation patterns
    if (gitAnalysis?.codeEvolution && vibeAnalysis?.patterns?.developmentThemes) {
      const correlation = this.correlatePatternsAcrossSources(
        gitAnalysis.codeEvolution,
        vibeAnalysis.patterns.developmentThemes
      );

      if (correlation) {
        observations.push(correlation);
      }
    }

    return observations;
  }

  private correlatePatternsAcrossSources(
    gitPatterns: any[],
    vibeThemes: any[]
  ): StructuredObservation | null {
    try {
      const entityName = this.generateEntityName('CrossAnalysis', 'GitVibeCorrelation');
      const currentDate = new Date().toISOString();

      const topGitPattern = gitPatterns[0]?.pattern || 'No pattern';
      const topVibeTheme = vibeThemes[0]?.theme || 'No theme';

      const observations: ObservationTemplate[] = [
        {
          type: 'learning',
          content: `Correlation identified between git activity (${topGitPattern}) and conversation focus (${topVibeTheme})`,
          date: currentDate,
          metadata: {
            transferable: true,
            domain: 'cross-analysis'
          }
        },
        {
          type: 'rationale',
          content: 'Cross-source analysis reveals alignment between code changes and development discussions',
          date: currentDate,
          metadata: {
            factors: ['git-analysis', 'conversation-analysis', 'pattern-correlation'],
            tradeoffs: ['comprehensive view', 'complex analysis']
          }
        },
        {
          type: 'applicability',
          content: 'Pattern applicable to projects with active development and documentation through conversations',
          date: currentDate,
          metadata: {
            scope: 'active-development',
            generalizability: 'medium'
          }
        }
      ];

      return {
        entityName,
        entityType: 'CrossAnalysisPattern',
        significance: 8,
        observations,
        tags: ['cross-analysis', 'correlation', 'git-vibe', 'pattern'],
        relationships: [
          {
            type: 'correlates',
            target: 'GitHistoryAnalysis',
            description: 'Correlates git patterns with conversation themes'
          },
          {
            type: 'correlates',
            target: 'VibeHistoryAnalysis',
            description: 'Correlates conversation themes with git patterns'
          }
        ],
        metadata: {
          generatedAt: currentDate,
          sourceData: ['git-history', 'vibe-history'],
          confidence: 0.75,
          validationStatus: 'pending'
        }
      };

    } catch (error) {
      log('Failed to create cross-analysis observation', 'error', error);
      return null;
    }
  }

  private async enhanceWithWebSearch(
    observations: StructuredObservation[],
    webSearchResults: any
  ): Promise<void> {
    // Add reference observations from web search results
    observations.forEach(observation => {
      if (webSearchResults?.references) {
        observation.observations.push({
          type: 'reference',
          content: `External resources: ${webSearchResults.references.slice(0, 3).join(', ')}`,
          date: new Date().toISOString(),
          metadata: {
            source: 'web-search',
            reliability: 'medium'
          }
        });
      }
    });
  }

  public validateObservations(observations: StructuredObservation[]): ObservationGenerationResult['validationReport'] {
    let structureCompliance = 0;
    let contentQuality = 0;
    let templateAdherence = 0;
    const issues: string[] = [];

    for (const observation of observations) {
      // Structure compliance
      const hasRequiredFields = !!(observation.entityName && observation.entityType && observation.observations);
      const hasValidSignificance = observation.significance >= 1 && observation.significance <= 10;
      const hasObservations = observation.observations.length > 0;
      
      if (hasRequiredFields && hasValidSignificance && hasObservations) {
        structureCompliance++;
      } else {
        issues.push(`${observation.entityName}: Structure compliance issues`);
      }

      // Content quality
      const hasSubstantialContent = observation.observations.some(obs => obs.content.length > 50);
      const hasVariedObservations = new Set(observation.observations.map(obs => obs.type)).size > 1;
      
      if (hasSubstantialContent && hasVariedObservations) {
        contentQuality++;
      } else {
        issues.push(`${observation.entityName}: Content quality issues`);
      }

      // Template adherence
      const hasValidTypes = observation.observations.every(obs => 
        ['problem', 'solution', 'rationale', 'learning', 'applicability', 'technology', 'reference', 'metric'].includes(obs.type)
      );
      const hasMetadata = observation.observations.every(obs => obs.metadata);
      
      if (hasValidTypes && hasMetadata) {
        templateAdherence++;
      } else {
        issues.push(`${observation.entityName}: Template adherence issues`);
      }
    }

    const total = observations.length || 1;
    return {
      structureCompliance: Math.round((structureCompliance / total) * 100),
      contentQuality: Math.round((contentQuality / total) * 100),
      templateAdherence: Math.round((templateAdherence / total) * 100),
      issues
    };
  }

  private generateSummary(observations: StructuredObservation[]): ObservationGenerationResult['summary'] {
    const byType: Record<string, number> = {};
    let totalSignificance = 0;

    observations.forEach(observation => {
      byType[observation.entityType] = (byType[observation.entityType] || 0) + 1;
      totalSignificance += observation.significance;
    });

    const averageSignificance = observations.length > 0 ? Math.round(totalSignificance / observations.length) : 0;
    
    // Calculate quality score based on various factors
    const avgObservationsPerEntity = observations.length > 0 
      ? observations.reduce((sum, obs) => sum + obs.observations.length, 0) / observations.length 
      : 0;
    const avgRelationships = observations.length > 0
      ? observations.reduce((sum, obs) => sum + obs.relationships.length, 0) / observations.length
      : 0;

    const qualityScore = Math.min(
      Math.round((averageSignificance / 10) * 40 + (avgObservationsPerEntity / 5) * 30 + (avgRelationships / 2) * 30),
      100
    );

    return {
      totalGenerated: observations.length,
      byType,
      averageSignificance,
      qualityScore
    };
  }

  // Helper methods
  private generateEntityName(type: string, description: string): string {
    // Create a clean, CamelCase entity name that matches existing patterns
    const cleaned = description
      .replace(/[^a-zA-Z0-9\s]/g, '')
      .trim()
      .split(/\s+/)
      .slice(0, 3) // Max 3 words to keep it concise
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join('');

    // Combine type and cleaned description
    const typeCapitalized = type.charAt(0).toUpperCase() + type.slice(1).toLowerCase();
    return `${typeCapitalized}${cleaned}Pattern`;
  }

  private calculateSignificance(impact: string, fileCount: number): number {
    // Match existing significance patterns: mostly 5, sometimes 8-9 for critical
    switch (impact) {
      case 'high': 
        return fileCount > 15 ? 9 : 8; // 9 for very large changes, 8 for high impact
      case 'medium': 
        return 5; // Standard significance
      case 'low': 
        return 5; // Still valuable for knowledge base
      default: 
        return 5;
    }
  }

  private calculateSignificanceFromDifficulty(difficulty: string): number {
    // Match existing significance patterns
    switch (difficulty) {
      case 'high': return 8;
      case 'medium': return 5;
      case 'low': return 5; // Still valuable
      default: return 5;
    }
  }

  private extractTechnologiesFromFiles(files: string[]): string[] {
    const technologies = new Set<string>();
    
    files.forEach(file => {
      const ext = path.extname(file).toLowerCase();
      switch (ext) {
        case '.ts': technologies.add('TypeScript'); break;
        case '.js': technologies.add('JavaScript'); break;
        case '.json': technologies.add('JSON'); break;
        case '.md': technologies.add('Markdown'); break;
        case '.py': technologies.add('Python'); break;
        case '.yml':
        case '.yaml': technologies.add('YAML'); break;
      }
    });
    
    return Array.from(technologies);
  }

  private extractCommonTechnologies(contexts: any[]): string[] {
    const techCounts = new Map<string, number>();
    
    contexts.forEach(context => {
      if (context.technicalDetails) {
        context.technicalDetails.forEach((detail: string) => {
          if (detail.startsWith('Tool: ')) {
            const tool = detail.replace('Tool: ', '');
            techCounts.set(tool, (techCounts.get(tool) || 0) + 1);
          }
        });
      }
    });
    
    return Array.from(techCounts.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, 5)
      .map(([tech]) => tech);
  }

  private interpretTrend(trend: string, pattern: string): string {
    switch (trend) {
      case 'increasing':
        return `growing emphasis on ${pattern}`;
      case 'decreasing':
        return `reduced focus on ${pattern}`;
      case 'stable':
        return `consistent approach to ${pattern}`;
      default:
        return `ongoing ${pattern} activity`;
    }
  }
}